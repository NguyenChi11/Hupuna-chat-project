{"version":3,"sources":["../../../src/app/api/upload/route.ts","../../../node_modules/next/dist/esm/build/templates/app-route.js","../../../node_modules/pocketbase/src/ClientResponseError.ts","../../../node_modules/next/src/build/templates/app-route.ts","../../../node_modules/pocketbase/src/tools/cookie.ts","../../../node_modules/pocketbase/src/tools/jwt.ts","../../../node_modules/pocketbase/src/stores/BaseAuthStore.ts","../../../node_modules/pocketbase/src/stores/LocalAuthStore.ts","../../../node_modules/pocketbase/src/services/BaseService.ts","../../../node_modules/pocketbase/src/services/SettingsService.ts","../../../node_modules/pocketbase/src/tools/options.ts","../../../node_modules/pocketbase/src/services/RealtimeService.ts","../../../node_modules/pocketbase/src/services/CrudService.ts","../../../node_modules/pocketbase/src/tools/legacy.ts","../../../node_modules/pocketbase/src/tools/refresh.ts","../../../node_modules/pocketbase/src/services/RecordService.ts","../../../node_modules/pocketbase/src/services/CollectionService.ts","../../../node_modules/pocketbase/src/services/LogService.ts","../../../node_modules/pocketbase/src/services/HealthService.ts","../../../node_modules/pocketbase/src/services/FileService.ts","../../../node_modules/pocketbase/src/services/BackupService.ts","../../../node_modules/pocketbase/src/services/CronService.ts","../../../node_modules/pocketbase/src/tools/formdata.ts","../../../node_modules/pocketbase/src/services/BatchService.ts","../../../node_modules/pocketbase/src/Client.ts","../../../node_modules/pocketbase/src/stores/AsyncAuthStore.ts"],"sourcesContent":["// app/api/upload/route.ts\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport PocketBase, { ClientResponseError } from 'pocketbase';\r\nimport { MessageCreate, MessageType, MESSAGES_COLLECTION_NAME } from '@/types/Message';\r\nimport { setProgress, clearProgress, getProgress } from '@/lib/uploadStore';\r\nimport { addRow } from '@/lib/mongoDBCRUD';\r\n\r\nexport const runtime = 'nodejs';\r\n\r\nexport async function GET(req: NextRequest) {\r\n  const id = req.nextUrl.searchParams.get('uploadId');\r\n  if (!id) return NextResponse.json({ error: 'Missing ID' }, { status: 400 });\r\n  const raw = getProgress(id);\r\n  const percent = raw === -1 ? 0 : raw;\r\n  return NextResponse.json({ id, percent, formattedPercent: `${Math.round(percent)}%` });\r\n}\r\n\r\nexport async function POST(req: NextRequest) {\r\n  const uploadId = req.nextUrl.searchParams.get('uploadId') || 'unknown';\r\n  console.log('--- BẮT ĐẦU API UPLOAD (SERVER SIDE) ---', uploadId);\r\n\r\n  try {\r\n    setProgress(uploadId, 0);\r\n\r\n    // 1. Lấy dữ liệu FormData từ Client gửi lên\r\n    const formData = await req.formData();\r\n    const file = formData.get('file');\r\n\r\n    // Kiểm tra file có tồn tại và đúng kiểu không\r\n    if (!file || !(file instanceof File)) {\r\n      return NextResponse.json({ success: false, message: 'File không hợp lệ' }, { status: 400 });\r\n    }\r\n\r\n    // Các field phụ\r\n    const roomId = formData.get('roomId') as string;\r\n    const sender = formData.get('sender') as string;\r\n    const receiver = (formData.get('receiver') as string) || '';\r\n    const type = formData.get('type') as MessageType;\r\n    const batchId = (formData.get('batchId') as string) || undefined;\r\n    const skipSaveMessage = formData.get('skipSaveMessage') === 'true';\r\n\r\n    // 2. Lấy cấu hình từ biến môi trường\r\n    const pbUrl = process.env.NEXT_PUBLIC_POCKETBASE_URL || 'https://files.hupuna.vn/';\r\n    const identity = process.env.NEXT_PUBLIC_POCKETBASE_USER_ID;\r\n    const password = process.env.NEXT_PUBLIC_POCKETBASE_PASSWORD;\r\n    const collectionName = process.env.NEXT_PUBLIC_POCKETBASE_COLLECTION_FILES || 'files';\r\n\r\n    if (!identity || !password) {\r\n      return NextResponse.json({ success: false, message: 'Lỗi cấu hình server: Thiếu .env' }, { status: 500 });\r\n    }\r\n\r\n    // 3. Kết nối & Đăng nhập\r\n    const pb = new PocketBase(pbUrl);\r\n    pb.autoCancellation(false); // Tắt tự hủy request để upload ổn định\r\n\r\n    try {\r\n      // Đăng nhập bằng tài khoản trong .env\r\n      // Ưu tiên admin auth nếu có thể, hoặc user auth\r\n      try {\r\n        await pb.admins.authWithPassword(identity, password);\r\n      } catch {\r\n        // Fallback user auth\r\n        await pb.collection('users').authWithPassword(identity, password);\r\n      }\r\n    } catch (e: unknown) {\r\n      console.error('Lỗi đăng nhập System PB:', e);\r\n      return NextResponse.json(\r\n        { success: false, message: 'Không thể đăng nhập vào hệ thống lưu trữ' },\r\n        { status: 401 },\r\n      );\r\n    }\r\n\r\n    // 4. Chuẩn bị dữ liệu gửi sang PocketBase\r\n    const pbFormData = new FormData();\r\n    pbFormData.append('file', file);\r\n    // Title là bắt buộc\r\n    const title = (formData.get('title') as string) || file.name;\r\n    pbFormData.append('title', title);\r\n\r\n    // Các field khác nếu cần\r\n    if (formData.has('folder')) {\r\n      pbFormData.append('folder', formData.get('folder') as string);\r\n    }\r\n\r\n    // Gán owner là ID của tài khoản hệ thống (để file có chủ sở hữu) hoặc sender nếu sender là ID hợp lệ trong hệ thống\r\n    // Tuy nhiên, an toàn nhất là dùng ID của tài khoản đang đăng nhập (admin/bot) làm owner ban đầu\r\n    if (pb.authStore.model?.id) {\r\n      pbFormData.append('users_id', pb.authStore.model.id);\r\n    }\r\n\r\n    setProgress(uploadId, 10);\r\n\r\n    // 5. Thực hiện Upload\r\n    const record = await pb.collection(collectionName).create(pbFormData);\r\n\r\n    setProgress(uploadId, 100);\r\n\r\n    // 6. Tạo URL hiển thị\r\n    const baseUrl = pbUrl.endsWith('/') ? pbUrl.slice(0, -1) : pbUrl;\r\n    const fullUrl = `${baseUrl}/api/files/${record.collectionId}/${record.id}/${record.file}`;\r\n\r\n    // 7. Lưu message vào MongoDB (Logic cũ)\r\n    const messageData: MessageCreate = {\r\n      roomId,\r\n      sender,\r\n      receiver,\r\n      type,\r\n      fileName: record.file, // Dùng tên file từ PB\r\n      fileUrl: fullUrl,\r\n      timestamp: Date.now(),\r\n      batchId,\r\n      uploadId,\r\n    };\r\n\r\n    let insertedId: string | undefined = undefined;\r\n    if (!skipSaveMessage && roomId) {\r\n      try {\r\n        insertedId = await addRow(MESSAGES_COLLECTION_NAME, messageData as MessageCreate & Record<string, unknown>);\r\n      } catch (e) {\r\n        console.error('Lỗi lưu DB:', e);\r\n      }\r\n    }\r\n\r\n    setTimeout(() => clearProgress(uploadId), 2000);\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      link: fullUrl,\r\n      data: messageData,\r\n      _id: insertedId,\r\n      saved: !!insertedId,\r\n      // Data format theo yêu cầu mới\r\n      result: {\r\n        id: record.id,\r\n        url: fullUrl,\r\n        filename: record.file,\r\n      },\r\n    });\r\n  } catch (error: unknown) {\r\n    console.error('❌ Lỗi API Upload:', error);\r\n    setProgress(uploadId, -1);\r\n\r\n    let errorMessage = 'Lỗi server nội bộ';\r\n    let statusCode = 500;\r\n\r\n    if (error instanceof ClientResponseError) {\r\n      statusCode = error.status;\r\n      errorMessage = error.message;\r\n      console.error('PB Response:', error.response);\r\n    } else if (error instanceof Error) {\r\n      errorMessage = error.message;\r\n    }\r\n\r\n    return NextResponse.json({ success: false, message: errorMessage }, { status: statusCode });\r\n  }\r\n}\r\n","import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setReferenceManifestsSingleton } from \"next/dist/esm/server/app-render/encryption-utils\";\nimport { createServerModuleMap } from \"next/dist/esm/server/app-render/action-utils\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/upload/route\",\n        pathname: \"/api/upload\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/src/app/api/upload/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/upload/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setReferenceManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest,\n            serverModuleMap: createServerModuleMap({\n                serverActionsManifest\n            })\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","/**\n * ClientResponseError is a custom Error class that is intended to wrap\n * and normalize any error thrown by `Client.send()`.\n */\nexport class ClientResponseError extends Error {\n    url: string = \"\";\n    status: number = 0;\n    response: { [key: string]: any } = {};\n    isAbort: boolean = false;\n    originalError: any = null;\n\n    constructor(errData?: any) {\n        super(\"ClientResponseError\");\n\n        // Set the prototype explicitly.\n        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, ClientResponseError.prototype);\n\n        if (errData !== null && typeof errData === \"object\") {\n            this.url = typeof errData.url === \"string\" ? errData.url : \"\";\n            this.status = typeof errData.status === \"number\" ? errData.status : 0;\n            this.isAbort = !!errData.isAbort;\n            this.originalError = errData.originalError;\n\n            if (errData.response !== null && typeof errData.response === \"object\") {\n                this.response = errData.response;\n            } else if (errData.data !== null && typeof errData.data === \"object\") {\n                this.response = errData.data;\n            } else {\n                this.response = {};\n            }\n        }\n\n        if (!this.originalError && !(errData instanceof ClientResponseError)) {\n            this.originalError = errData;\n        }\n\n        if (\n            typeof DOMException !== \"undefined\" &&\n            errData instanceof DOMException &&\n            // https://developer.mozilla.org/en-US/docs/Web/API/DOMException#aborterror\n            (errData.name == \"AbortError\" || errData.code == 20)\n        ) {\n            this.isAbort = true;\n        }\n\n        this.name = \"ClientResponseError \" + this.status;\n        this.message = this.response?.message;\n        if (!this.message) {\n            if (this.isAbort) {\n                this.message =\n                    \"The request was autocancelled. You can find more info in https://github.com/pocketbase/js-sdk#auto-cancellation.\";\n            } else if (this.originalError?.cause?.message?.includes(\"ECONNREFUSED ::1\")) {\n                this.message =\n                    \"Failed to connect to the PocketBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/pocketbase/js-sdk/issues/21).\";\n            } else {\n                this.message = \"Something went wrong.\";\n            }\n        }\n\n        // set this.cause so that JS debugging tools can automatically connect\n        // the dots between the original error and the wrapped one\n        this.cause = this.originalError;\n    }\n\n    /**\n     * Alias for `this.response` for backward compatibility.\n     */\n    get data() {\n        return this.response;\n    }\n\n    /**\n     * Make a POJO's copy of the current error class instance.\n     * @see https://github.com/vuex-orm/vuex-orm/issues/255\n     */\n    toJSON() {\n        return { ...this };\n    }\n}\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (error, _request, errorContext) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      await routeModule.onRequestError(req, err, {\n        routerKind: 'App Router',\n        routePath: normalizedSrcPage,\n        routeType: 'route',\n        revalidateReason: getRevalidateReason({\n          isStaticGeneration,\n          isOnDemandRevalidate,\n        }),\n      })\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n","/**\n * -------------------------------------------------------------------\n * Simple cookie parse and serialize utilities mostly based on the\n * node module https://github.com/jshttp/cookie.\n * -------------------------------------------------------------------\n */\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\nexport interface ParseOptions {\n    decode?: (val: string) => string;\n}\n\n/**\n * Parses the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n */\nexport function cookieParse(str: string, options?: ParseOptions): { [key: string]: any } {\n    const result: { [key: string]: any } = {};\n\n    if (typeof str !== \"string\") {\n        return result;\n    }\n\n    const opt = Object.assign({}, options || {});\n    const decode = opt.decode || defaultDecode;\n\n    let index = 0;\n    while (index < str.length) {\n        const eqIdx = str.indexOf(\"=\", index);\n\n        // no more cookie pairs\n        if (eqIdx === -1) {\n            break;\n        }\n\n        let endIdx = str.indexOf(\";\", index);\n\n        if (endIdx === -1) {\n            endIdx = str.length;\n        } else if (endIdx < eqIdx) {\n            // backtrack on prior semicolon\n            index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n            continue;\n        }\n\n        const key = str.slice(index, eqIdx).trim();\n\n        // only assign once\n        if (undefined === result[key]) {\n            let val = str.slice(eqIdx + 1, endIdx).trim();\n\n            // quoted values\n            if (val.charCodeAt(0) === 0x22) {\n                val = val.slice(1, -1);\n            }\n\n            try {\n                result[key] = decode(val);\n            } catch (_) {\n                result[key] = val; // no decoding\n            }\n        }\n\n        index = endIdx + 1;\n    }\n\n    return result;\n}\n\nexport interface SerializeOptions {\n    encode?: (val: string | number | boolean) => string;\n    maxAge?: number;\n    domain?: string;\n    path?: string;\n    expires?: Date;\n    httpOnly?: boolean;\n    secure?: boolean;\n    priority?: string;\n    sameSite?: boolean | string;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * ```js\n * cookieSerialize('foo', 'bar', { httpOnly: true }) // \"foo=bar; httpOnly\"\n * ```\n */\nexport function cookieSerialize(\n    name: string,\n    val: string,\n    options?: SerializeOptions,\n): string {\n    const opt = Object.assign({}, options || {});\n    const encode = opt.encode || defaultEncode;\n\n    if (!fieldContentRegExp.test(name)) {\n        throw new TypeError(\"argument name is invalid\");\n    }\n\n    const value = encode(val);\n\n    if (value && !fieldContentRegExp.test(value)) {\n        throw new TypeError(\"argument val is invalid\");\n    }\n\n    let result = name + \"=\" + value;\n\n    if (opt.maxAge != null) {\n        const maxAge = opt.maxAge - 0;\n\n        if (isNaN(maxAge) || !isFinite(maxAge)) {\n            throw new TypeError(\"option maxAge is invalid\");\n        }\n\n        result += \"; Max-Age=\" + Math.floor(maxAge);\n    }\n\n    if (opt.domain) {\n        if (!fieldContentRegExp.test(opt.domain)) {\n            throw new TypeError(\"option domain is invalid\");\n        }\n\n        result += \"; Domain=\" + opt.domain;\n    }\n\n    if (opt.path) {\n        if (!fieldContentRegExp.test(opt.path)) {\n            throw new TypeError(\"option path is invalid\");\n        }\n\n        result += \"; Path=\" + opt.path;\n    }\n\n    if (opt.expires) {\n        if (!isDate(opt.expires) || isNaN(opt.expires.valueOf())) {\n            throw new TypeError(\"option expires is invalid\");\n        }\n\n        result += \"; Expires=\" + opt.expires.toUTCString();\n    }\n\n    if (opt.httpOnly) {\n        result += \"; HttpOnly\";\n    }\n\n    if (opt.secure) {\n        result += \"; Secure\";\n    }\n\n    if (opt.priority) {\n        const priority =\n            typeof opt.priority === \"string\" ? opt.priority.toLowerCase() : opt.priority;\n\n        switch (priority) {\n            case \"low\":\n                result += \"; Priority=Low\";\n                break;\n            case \"medium\":\n                result += \"; Priority=Medium\";\n                break;\n            case \"high\":\n                result += \"; Priority=High\";\n                break;\n            default:\n                throw new TypeError(\"option priority is invalid\");\n        }\n    }\n\n    if (opt.sameSite) {\n        const sameSite =\n            typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n        switch (sameSite) {\n            case true:\n                result += \"; SameSite=Strict\";\n                break;\n            case \"lax\":\n                result += \"; SameSite=Lax\";\n                break;\n            case \"strict\":\n                result += \"; SameSite=Strict\";\n                break;\n            case \"none\":\n                result += \"; SameSite=None\";\n                break;\n            default:\n                throw new TypeError(\"option sameSite is invalid\");\n        }\n    }\n\n    return result;\n}\n\n/**\n * Default URL-decode string value function.\n * Optimized to skip native call when no `%`.\n */\nfunction defaultDecode(val: string): string {\n    return val.indexOf(\"%\") !== -1 ? decodeURIComponent(val) : val;\n}\n\n/**\n * Default URL-encode value function.\n */\nfunction defaultEncode(val: string | number | boolean): string {\n    return encodeURIComponent(val);\n}\n\n/**\n * Determines if value is a Date.\n */\nfunction isDate(val: any): boolean {\n    return Object.prototype.toString.call(val) === \"[object Date]\" || val instanceof Date;\n}\n","// @todo remove after https://github.com/reactwg/react-native-releases/issues/287\nconst isReactNative =\n    (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") ||\n    (typeof global !== \"undefined\" && (global as any).HermesInternal);\n\nlet atobPolyfill: Function;\nif (typeof atob === \"function\" && !isReactNative) {\n    atobPolyfill = atob;\n} else {\n    /**\n     * The code was extracted from:\n     * https://github.com/davidchambers/Base64.js\n     */\n    atobPolyfill = (input: any) => {\n        const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n        let str = String(input).replace(/=+$/, \"\");\n        if (str.length % 4 == 1) {\n            throw new Error(\n                \"'atob' failed: The string to be decoded is not correctly encoded.\",\n            );\n        }\n\n        for (\n            // initialize result and counters\n            var bc = 0, bs, buffer, idx = 0, output = \"\";\n            // get next character\n            (buffer = str.charAt(idx++));\n            // character found in table? initialize bit storage and add its ascii value;\n            ~buffer &&\n            ((bs = bc % 4 ? (bs as any) * 64 + buffer : buffer),\n            // and if not first of each 4 characters,\n            // convert the first 8 bits to one ascii character\n            bc++ % 4)\n                ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n                : 0\n        ) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n\n        return output;\n    };\n}\n\n/**\n * Returns JWT token's payload data.\n */\nexport function getTokenPayload(token: string): { [key: string]: any } {\n    if (token) {\n        try {\n            const encodedPayload = decodeURIComponent(\n                atobPolyfill(token.split(\".\")[1])\n                    .split(\"\")\n                    .map(function (c: string) {\n                        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n                    })\n                    .join(\"\"),\n            );\n\n            return JSON.parse(encodedPayload) || {};\n        } catch (e) {}\n    }\n\n    return {};\n}\n\n/**\n * Checks whether a JWT token is expired or not.\n * Tokens without `exp` payload key are considered valid.\n * Tokens with empty payload (eg. invalid token strings) are considered expired.\n *\n * @param token The token to check.\n * @param [expirationThreshold] Time in seconds that will be subtracted from the token `exp` property.\n */\nexport function isTokenExpired(token: string, expirationThreshold = 0): boolean {\n    let payload = getTokenPayload(token);\n\n    if (\n        Object.keys(payload).length > 0 &&\n        (!payload.exp || payload.exp - expirationThreshold > Date.now() / 1000)\n    ) {\n        return false;\n    }\n\n    return true;\n}\n","import { cookieParse, cookieSerialize, SerializeOptions } from \"@/tools/cookie\";\nimport { isTokenExpired, getTokenPayload } from \"@/tools/jwt\";\nimport { RecordModel } from \"@/tools/dtos\";\n\nexport type AuthRecord = RecordModel | null;\n\nexport type AuthModel = AuthRecord; // for backward compatibility\n\nexport type OnStoreChangeFunc = (token: string, record: AuthRecord) => void;\n\nconst defaultCookieKey = \"pb_auth\";\n\n/**\n * Base AuthStore class that stores the auth state in runtime memory (aka. only for the duration of the store instane).\n *\n * Usually you wouldn't use it directly and instead use the builtin LocalAuthStore, AsyncAuthStore\n * or extend it with your own custom implementation.\n */\nexport class BaseAuthStore {\n    protected baseToken: string = \"\";\n    protected baseModel: AuthRecord = null;\n\n    private _onChangeCallbacks: Array<OnStoreChangeFunc> = [];\n\n    /**\n     * Retrieves the stored token (if any).\n     */\n    get token(): string {\n        return this.baseToken;\n    }\n\n    /**\n     * Retrieves the stored model data (if any).\n     */\n    get record(): AuthRecord {\n        return this.baseModel;\n    }\n\n    /**\n     * @deprecated use `record` instead.\n     */\n    get model(): AuthRecord {\n        return this.baseModel;\n    }\n\n    /**\n     * Loosely checks if the store has valid token (aka. existing and unexpired exp claim).\n     */\n    get isValid(): boolean {\n        return !isTokenExpired(this.token);\n    }\n\n    /**\n     * Loosely checks whether the currently loaded store state is for superuser.\n     *\n     * Alternatively you can also compare directly `pb.authStore.record?.collectionName`.\n     */\n    get isSuperuser(): boolean {\n        let payload = getTokenPayload(this.token);\n\n        return (\n            payload.type == \"auth\" &&\n            (this.record?.collectionName == \"_superusers\" ||\n                // fallback in case the record field is not populated and assuming\n                // that the collection crc32 checksum id wasn't manually changed\n                (!this.record?.collectionName &&\n                    payload.collectionId == \"pbc_3142635823\"))\n        );\n    }\n\n    /**\n     * @deprecated use `isSuperuser` instead or simply check the record.collectionName property.\n     */\n    get isAdmin(): boolean {\n        console.warn(\n            \"Please replace pb.authStore.isAdmin with pb.authStore.isSuperuser OR simply check the value of pb.authStore.record?.collectionName\",\n        );\n        return this.isSuperuser;\n    }\n\n    /**\n     * @deprecated use `!isSuperuser` instead or simply check the record.collectionName property.\n     */\n    get isAuthRecord(): boolean {\n        console.warn(\n            \"Please replace pb.authStore.isAuthRecord with !pb.authStore.isSuperuser OR simply check the value of pb.authStore.record?.collectionName\",\n        );\n        return getTokenPayload(this.token).type == \"auth\" && !this.isSuperuser;\n    }\n\n    /**\n     * Saves the provided new token and model data in the auth store.\n     */\n    save(token: string, record?: AuthRecord): void {\n        this.baseToken = token || \"\";\n        this.baseModel = record || null;\n\n        this.triggerChange();\n    }\n\n    /**\n     * Removes the stored token and model data form the auth store.\n     */\n    clear(): void {\n        this.baseToken = \"\";\n        this.baseModel = null;\n        this.triggerChange();\n    }\n\n    /**\n     * Parses the provided cookie string and updates the store state\n     * with the cookie's token and model data.\n     *\n     * NB! This function doesn't validate the token or its data.\n     * Usually this isn't a concern if you are interacting only with the\n     * PocketBase API because it has the proper server-side security checks in place,\n     * but if you are using the store `isValid` state for permission controls\n     * in a node server (eg. SSR), then it is recommended to call `authRefresh()`\n     * after loading the cookie to ensure an up-to-date token and model state.\n     * For example:\n     *\n     * ```js\n     * pb.authStore.loadFromCookie(\"cookie string...\");\n     *\n     * try {\n     *     // get an up-to-date auth store state by veryfing and refreshing the loaded auth model (if any)\n     *     pb.authStore.isValid && await pb.collection('users').authRefresh();\n     * } catch (_) {\n     *     // clear the auth store on failed refresh\n     *     pb.authStore.clear();\n     * }\n     * ```\n     */\n    loadFromCookie(cookie: string, key = defaultCookieKey): void {\n        const rawData = cookieParse(cookie || \"\")[key] || \"\";\n\n        let data: { [key: string]: any } = {};\n        try {\n            data = JSON.parse(rawData);\n            // normalize\n            if (typeof data === null || typeof data !== \"object\" || Array.isArray(data)) {\n                data = {};\n            }\n        } catch (_) {}\n\n        this.save(data.token || \"\", data.record || data.model || null);\n    }\n\n    /**\n     * Exports the current store state as cookie string.\n     *\n     * By default the following optional attributes are added:\n     * - Secure\n     * - HttpOnly\n     * - SameSite=Strict\n     * - Path=/\n     * - Expires={the token expiration date}\n     *\n     * NB! If the generated cookie exceeds 4096 bytes, this method will\n     * strip the model data to the bare minimum to try to fit within the\n     * recommended size in https://www.rfc-editor.org/rfc/rfc6265#section-6.1.\n     */\n    exportToCookie(options?: SerializeOptions, key = defaultCookieKey): string {\n        const defaultOptions: SerializeOptions = {\n            secure: true,\n            sameSite: true,\n            httpOnly: true,\n            path: \"/\",\n        };\n\n        // extract the token expiration date\n        const payload = getTokenPayload(this.token);\n        if (payload?.exp) {\n            defaultOptions.expires = new Date(payload.exp * 1000);\n        } else {\n            defaultOptions.expires = new Date(\"1970-01-01\");\n        }\n\n        // merge with the user defined options\n        options = Object.assign({}, defaultOptions, options);\n\n        const rawData = {\n            token: this.token,\n            record: this.record ? JSON.parse(JSON.stringify(this.record)) : null,\n        };\n\n        let result = cookieSerialize(key, JSON.stringify(rawData), options);\n\n        const resultLength =\n            typeof Blob !== \"undefined\" ? new Blob([result]).size : result.length;\n\n        // strip down the model data to the bare minimum\n        if (rawData.record && resultLength > 4096) {\n            rawData.record = { id: rawData.record?.id, email: rawData.record?.email };\n            const extraProps = [\"collectionId\", \"collectionName\", \"verified\"];\n            for (const prop in this.record) {\n                if (extraProps.includes(prop)) {\n                    rawData.record[prop] = this.record[prop];\n                }\n            }\n            result = cookieSerialize(key, JSON.stringify(rawData), options);\n        }\n\n        return result;\n    }\n\n    /**\n     * Register a callback function that will be called on store change.\n     *\n     * You can set the `fireImmediately` argument to true in order to invoke\n     * the provided callback right after registration.\n     *\n     * Returns a removal function that you could call to \"unsubscribe\" from the changes.\n     */\n    onChange(callback: OnStoreChangeFunc, fireImmediately = false): () => void {\n        this._onChangeCallbacks.push(callback);\n\n        if (fireImmediately) {\n            callback(this.token, this.record);\n        }\n\n        return () => {\n            for (let i = this._onChangeCallbacks.length - 1; i >= 0; i--) {\n                if (this._onChangeCallbacks[i] == callback) {\n                    delete this._onChangeCallbacks[i]; // removes the function reference\n                    this._onChangeCallbacks.splice(i, 1); // reindex the array\n                    return;\n                }\n            }\n        };\n    }\n\n    protected triggerChange(): void {\n        for (const callback of this._onChangeCallbacks) {\n            callback && callback(this.token, this.record);\n        }\n    }\n}\n","import { BaseAuthStore, AuthRecord } from \"@/stores/BaseAuthStore\";\n\n/**\n * The default token store for browsers with auto fallback\n * to runtime/memory if local storage is undefined (e.g. in node env).\n */\nexport class LocalAuthStore extends BaseAuthStore {\n    private storageFallback: { [key: string]: any } = {};\n    private storageKey: string;\n\n    constructor(storageKey = \"pocketbase_auth\") {\n        super();\n\n        this.storageKey = storageKey;\n\n        this._bindStorageEvent();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get token(): string {\n        const data = this._storageGet(this.storageKey) || {};\n\n        return data.token || \"\";\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get record(): AuthRecord {\n        const data = this._storageGet(this.storageKey) || {};\n\n        return data.record || data.model || null;\n    }\n\n    /**\n     * @deprecated use `record` instead.\n     */\n    get model(): AuthRecord {\n        return this.record;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    save(token: string, record?: AuthRecord) {\n        this._storageSet(this.storageKey, {\n            token: token,\n            record: record,\n        });\n\n        super.save(token, record);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    clear() {\n        this._storageRemove(this.storageKey);\n\n        super.clear();\n    }\n\n    // ---------------------------------------------------------------\n    // Internal helpers:\n    // ---------------------------------------------------------------\n\n    /**\n     * Retrieves `key` from the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageGet(key: string): any {\n        if (typeof window !== \"undefined\" && window?.localStorage) {\n            const rawValue = window.localStorage.getItem(key) || \"\";\n            try {\n                return JSON.parse(rawValue);\n            } catch (e) {\n                // not a json\n                return rawValue;\n            }\n        }\n\n        // fallback\n        return this.storageFallback[key];\n    }\n\n    /**\n     * Stores a new data in the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageSet(key: string, value: any) {\n        if (typeof window !== \"undefined\" && window?.localStorage) {\n            // store in local storage\n            let normalizedVal = value;\n            if (typeof value !== \"string\") {\n                normalizedVal = JSON.stringify(value);\n            }\n            window.localStorage.setItem(key, normalizedVal);\n        } else {\n            // store in fallback\n            this.storageFallback[key] = value;\n        }\n    }\n\n    /**\n     * Removes `key` from the browser's local storage and the runtime/memory.\n     */\n    private _storageRemove(key: string) {\n        // delete from local storage\n        if (typeof window !== \"undefined\" && window?.localStorage) {\n            window.localStorage?.removeItem(key);\n        }\n\n        // delete from fallback\n        delete this.storageFallback[key];\n    }\n\n    /**\n     * Updates the current store state on localStorage change.\n     */\n    private _bindStorageEvent() {\n        if (\n            typeof window === \"undefined\" ||\n            !window?.localStorage ||\n            !window.addEventListener\n        ) {\n            return;\n        }\n\n        window.addEventListener(\"storage\", (e) => {\n            if (e.key != this.storageKey) {\n                return;\n            }\n\n            const data = this._storageGet(this.storageKey) || {};\n\n            super.save(data.token || \"\", data.record || data.model || null);\n        });\n    }\n}\n","import Client from \"@/Client\";\n\n/**\n * BaseService class that should be inherited from all API services.\n */\nexport abstract class BaseService {\n    readonly client: Client;\n\n    constructor(client: Client) {\n        this.client = client;\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { CommonOptions } from \"@/tools/options\";\n\ninterface appleClientSecret {\n    secret: string;\n}\n\nexport class SettingsService extends BaseService {\n    /**\n     * Fetch all available app settings.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getAll(options?: CommonOptions): Promise<{ [key: string]: any }> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings\", options);\n    }\n\n    /**\n     * Bulk updates app settings.\n     *\n     * @throws {ClientResponseError}\n     */\n    async update(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: any }> {\n        options = Object.assign(\n            {\n                method: \"PATCH\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings\", options);\n    }\n\n    /**\n     * Performs a S3 filesystem connection test.\n     *\n     * The currently supported `filesystem` are \"storage\" and \"backups\".\n     *\n     * @throws {ClientResponseError}\n     */\n    async testS3(\n        filesystem: string = \"storage\",\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    filesystem: filesystem,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings/test/s3\", options).then(() => true);\n    }\n\n    /**\n     * Sends a test email.\n     *\n     * The possible `emailTemplate` values are:\n     * - verification\n     * - password-reset\n     * - email-change\n     *\n     * @throws {ClientResponseError}\n     */\n    async testEmail(\n        collectionIdOrName: string,\n        toEmail: string,\n        emailTemplate: string,\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    email: toEmail,\n                    template: emailTemplate,\n                    collection: collectionIdOrName,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings/test/email\", options).then(() => true);\n    }\n\n    /**\n     * Generates a new Apple OAuth2 client secret.\n     *\n     * @throws {ClientResponseError}\n     */\n    async generateAppleClientSecret(\n        clientId: string,\n        teamId: string,\n        keyId: string,\n        privateKey: string,\n        duration: number,\n        options?: CommonOptions,\n    ): Promise<appleClientSecret> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    clientId,\n                    teamId,\n                    keyId,\n                    privateKey,\n                    duration,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/settings/apple/generate-client-secret\", options);\n    }\n}\n","export interface SendOptions extends RequestInit {\n    // for backward compatibility and to minimize the verbosity,\n    // any top-level field that doesn't exist in RequestInit or the\n    // fields below will be treated as query parameter.\n    [key: string]: any;\n\n    /**\n     * Optional custom fetch function to use for sending the request.\n     */\n    fetch?: (url: RequestInfo | URL, config?: RequestInit) => Promise<Response>;\n\n    /**\n     * Custom headers to send with the requests.\n     */\n    headers?: { [key: string]: string };\n\n    /**\n     * The body of the request (serialized automatically for json requests).\n     */\n    body?: any;\n\n    /**\n     * Query parameters that will be appended to the request url.\n     */\n    query?: { [key: string]: any };\n\n    /**\n     * @deprecated use `query` instead\n     *\n     * for backward-compatibility `params` values are merged with `query`,\n     * but this option may get removed in the final v1 release\n     */\n    params?: { [key: string]: any };\n\n    /**\n     * The request identifier that can be used to cancel pending requests.\n     */\n    requestKey?: string | null;\n\n    /**\n     * @deprecated use `requestKey:string` instead\n     */\n    $cancelKey?: string;\n\n    /**\n     * @deprecated use `requestKey:null` instead\n     */\n    $autoCancel?: boolean;\n}\n\nexport interface CommonOptions extends SendOptions {\n    fields?: string;\n}\n\nexport interface ListOptions extends CommonOptions {\n    page?: number;\n    perPage?: number;\n    sort?: string;\n    filter?: string;\n    skipTotal?: boolean;\n}\n\nexport interface FullListOptions extends ListOptions {\n    batch?: number;\n}\n\nexport interface RecordOptions extends CommonOptions {\n    expand?: string;\n}\n\nexport interface RecordListOptions extends ListOptions, RecordOptions {}\n\nexport interface RecordFullListOptions extends FullListOptions, RecordOptions {}\n\nexport interface RecordSubscribeOptions extends SendOptions {\n    fields?: string;\n    filter?: string;\n    expand?: string;\n}\n\nexport interface LogStatsOptions extends CommonOptions {\n    filter?: string;\n}\n\nexport interface FileOptions extends CommonOptions {\n    thumb?: string;\n    download?: boolean;\n}\n\nexport interface AuthOptions extends CommonOptions {\n    /**\n     * If autoRefreshThreshold is set it will take care to auto refresh\n     * when necessary the auth data before each request to ensure that\n     * the auth state is always valid.\n     *\n     * The value must be in seconds, aka. the amount of seconds\n     * that will be subtracted from the current token `exp` claim in order\n     * to determine whether it is going to expire within the specified time threshold.\n     *\n     * For example, if you want to auto refresh the token if it is\n     * going to expire in the next 30mins (or already has expired),\n     * it can be set to `1800`\n     */\n    autoRefreshThreshold?: number;\n}\n\n// -------------------------------------------------------------------\n\n// list of known SendOptions keys (everything else is treated as query param)\nconst knownSendOptionsKeys = [\n    \"requestKey\",\n    \"$cancelKey\",\n    \"$autoCancel\",\n    \"fetch\",\n    \"headers\",\n    \"body\",\n    \"query\",\n    \"params\",\n    // ---,\n    \"cache\",\n    \"credentials\",\n    \"headers\",\n    \"integrity\",\n    \"keepalive\",\n    \"method\",\n    \"mode\",\n    \"redirect\",\n    \"referrer\",\n    \"referrerPolicy\",\n    \"signal\",\n    \"window\",\n];\n\n// modifies in place the provided options by moving unknown send options as query parameters.\nexport function normalizeUnknownQueryParams(options?: SendOptions): void {\n    if (!options) {\n        return;\n    }\n\n    options.query = options.query || {};\n    for (let key in options) {\n        if (knownSendOptionsKeys.includes(key)) {\n            continue;\n        }\n\n        options.query[key] = options[key];\n        delete options[key];\n    }\n}\n\nexport function serializeQueryParams(params: { [key: string]: any }): string {\n    const result: Array<string> = [];\n\n    for (const key in params) {\n        const encodedKey = encodeURIComponent(key);\n        const arrValue = Array.isArray(params[key]) ? params[key] : [params[key]];\n\n        for (let v of arrValue) {\n            v = prepareQueryParamValue(v);\n            if (v === null) {\n                continue;\n            }\n            result.push(encodedKey + \"=\" + v);\n        }\n    }\n\n    return result.join(\"&\");\n}\n\n// encodes and normalizes the provided query param value.\nfunction prepareQueryParamValue(value: any): null | string {\n    if (value === null || typeof value === \"undefined\") {\n        return null;\n    }\n\n    if (value instanceof Date) {\n        return encodeURIComponent(value.toISOString().replace(\"T\", \" \"));\n    }\n\n    if (typeof value === \"object\") {\n        return encodeURIComponent(JSON.stringify(value));\n    }\n\n    return encodeURIComponent(value);\n}\n","import { ClientResponseError } from \"@/ClientResponseError\";\nimport { BaseService } from \"@/services/BaseService\";\nimport { SendOptions, normalizeUnknownQueryParams } from \"@/tools/options\";\n\ninterface promiseCallbacks {\n    resolve: Function;\n    reject: Function;\n}\n\ntype Subscriptions = { [key: string]: Array<EventListener> };\n\nexport type UnsubscribeFunc = () => Promise<void>;\n\nexport class RealtimeService extends BaseService {\n    clientId: string = \"\";\n\n    private eventSource: EventSource | null = null;\n    private subscriptions: Subscriptions = {};\n    private lastSentSubscriptions: Array<string> = [];\n    private connectTimeoutId: any;\n    private maxConnectTimeout: number = 15000;\n    private reconnectTimeoutId: any;\n    private reconnectAttempts: number = 0;\n    private maxReconnectAttempts: number = Infinity;\n    private predefinedReconnectIntervals: Array<number> = [\n        200, 300, 500, 1000, 1200, 1500, 2000,\n    ];\n    private pendingConnects: Array<promiseCallbacks> = [];\n\n    /**\n     * Returns whether the realtime connection has been established.\n     */\n    get isConnected(): boolean {\n        return !!this.eventSource && !!this.clientId && !this.pendingConnects.length;\n    }\n\n    /**\n     * An optional hook that is invoked when the realtime client disconnects\n     * either when unsubscribing from all subscriptions or when the\n     * connection was interrupted or closed by the server.\n     *\n     * The received argument could be used to determine whether the disconnect\n     * is a result from unsubscribing (`activeSubscriptions.length == 0`)\n     * or because of network/server error (`activeSubscriptions.length > 0`).\n     *\n     * If you want to listen for the opposite, aka. when the client connection is established,\n     * subscribe to the `PB_CONNECT` event.\n     */\n    onDisconnect?: (activeSubscriptions: Array<string>) => void;\n\n    /**\n     * Register the subscription listener.\n     *\n     * You can subscribe multiple times to the same topic.\n     *\n     * If the SSE connection is not started yet,\n     * this method will also initialize it.\n     */\n    async subscribe(\n        topic: string,\n        callback: (data: any) => void,\n        options?: SendOptions,\n    ): Promise<UnsubscribeFunc> {\n        if (!topic) {\n            throw new Error(\"topic must be set.\");\n        }\n\n        let key = topic;\n\n        // serialize and append the topic options (if any)\n        if (options) {\n            options = Object.assign({}, options); // shallow copy\n            normalizeUnknownQueryParams(options);\n            const serialized =\n                \"options=\" +\n                encodeURIComponent(\n                    JSON.stringify({ query: options.query, headers: options.headers }),\n                );\n            key += (key.includes(\"?\") ? \"&\" : \"?\") + serialized;\n        }\n\n        const listener = function (e: Event) {\n            const msgEvent = e as MessageEvent;\n\n            let data;\n            try {\n                data = JSON.parse(msgEvent?.data);\n            } catch {}\n\n            callback(data || {});\n        };\n\n        // store the listener\n        if (!this.subscriptions[key]) {\n            this.subscriptions[key] = [];\n        }\n        this.subscriptions[key].push(listener);\n\n        if (!this.isConnected) {\n            // initialize sse connection\n            await this.connect();\n        } else if (this.subscriptions[key].length === 1) {\n            // send the updated subscriptions (if it is the first for the key)\n            await this.submitSubscriptions();\n        } else {\n            // only register the listener\n            this.eventSource?.addEventListener(key, listener);\n        }\n\n        return async (): Promise<void> => {\n            return this.unsubscribeByTopicAndListener(topic, listener);\n        };\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners with the specified topic.\n     *\n     * If `topic` is not provided, then this method will unsubscribe\n     * from all active subscriptions.\n     *\n     * This method is no-op if there are no active subscriptions.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        let needToSubmit = false;\n\n        if (!topic) {\n            // remove all subscriptions\n            this.subscriptions = {};\n        } else {\n            // remove all listeners related to the topic\n            const subs = this.getSubscriptionsByTopic(topic);\n            for (let key in subs) {\n                if (!this.hasSubscriptionListeners(key)) {\n                    continue; // already unsubscribed\n                }\n\n                for (let listener of this.subscriptions[key]) {\n                    this.eventSource?.removeEventListener(key, listener);\n                }\n                delete this.subscriptions[key];\n\n                // mark for subscriptions change submit if there are no other listeners\n                if (!needToSubmit) {\n                    needToSubmit = true;\n                }\n            }\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (needToSubmit) {\n            await this.submitSubscriptions();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners starting with the specified topic prefix.\n     *\n     * This method is no-op if there are no active subscriptions with the specified topic prefix.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByPrefix(keyPrefix: string): Promise<void> {\n        let hasAtleastOneTopic = false;\n        for (let key in this.subscriptions) {\n            // \"?\" so that it can be used as end delimiter for the prefix\n            if (!(key + \"?\").startsWith(keyPrefix)) {\n                continue;\n            }\n\n            hasAtleastOneTopic = true;\n            for (let listener of this.subscriptions[key]) {\n                this.eventSource?.removeEventListener(key, listener);\n            }\n            delete this.subscriptions[key];\n        }\n\n        if (!hasAtleastOneTopic) {\n            return; // nothing to unsubscribe from\n        }\n\n        if (this.hasSubscriptionListeners()) {\n            // submit the deleted subscriptions\n            await this.submitSubscriptions();\n        } else {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscriptions matching the specified topic and listener function.\n     *\n     * This method is no-op if there are no active subscription with\n     * the specified topic and listener.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByTopicAndListener(\n        topic: string,\n        listener: EventListener,\n    ): Promise<void> {\n        let needToSubmit = false;\n\n        const subs = this.getSubscriptionsByTopic(topic);\n        for (let key in subs) {\n            if (\n                !Array.isArray(this.subscriptions[key]) ||\n                !this.subscriptions[key].length\n            ) {\n                continue; // already unsubscribed\n            }\n\n            let exist = false;\n            for (let i = this.subscriptions[key].length - 1; i >= 0; i--) {\n                if (this.subscriptions[key][i] !== listener) {\n                    continue;\n                }\n\n                exist = true; // has at least one matching listener\n                delete this.subscriptions[key][i]; // removes the function reference\n                this.subscriptions[key].splice(i, 1); // reindex the array\n                this.eventSource?.removeEventListener(key, listener);\n            }\n            if (!exist) {\n                continue;\n            }\n\n            // remove the key from the subscriptions list if there are no other listeners\n            if (!this.subscriptions[key].length) {\n                delete this.subscriptions[key];\n            }\n\n            // mark for subscriptions change submit if there are no other listeners\n            if (!needToSubmit && !this.hasSubscriptionListeners(key)) {\n                needToSubmit = true;\n            }\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (needToSubmit) {\n            await this.submitSubscriptions();\n        }\n    }\n\n    private hasSubscriptionListeners(keyToCheck?: string): boolean {\n        this.subscriptions = this.subscriptions || {};\n\n        // check the specified key\n        if (keyToCheck) {\n            return !!this.subscriptions[keyToCheck]?.length;\n        }\n\n        // check for at least one non-empty subscription\n        for (let key in this.subscriptions) {\n            if (!!this.subscriptions[key]?.length) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private async submitSubscriptions(): Promise<void> {\n        if (!this.clientId) {\n            return; // no client/subscriber\n        }\n\n        // optimistic update\n        this.addAllSubscriptionListeners();\n\n        this.lastSentSubscriptions = this.getNonEmptySubscriptionKeys();\n\n        return this.client\n            .send(\"/api/realtime\", {\n                method: \"POST\",\n                body: {\n                    clientId: this.clientId,\n                    subscriptions: this.lastSentSubscriptions,\n                },\n                requestKey: this.getSubscriptionsCancelKey(),\n            })\n            .catch((err) => {\n                if (err?.isAbort) {\n                    return; // silently ignore aborted pending requests\n                }\n                throw err;\n            });\n    }\n\n    private getSubscriptionsCancelKey(): string {\n        return \"realtime_\" + this.clientId;\n    }\n\n    private getSubscriptionsByTopic(topic: string): Subscriptions {\n        const result: Subscriptions = {};\n\n        // \"?\" so that it can be used as end delimiter for the topic\n        topic = topic.includes(\"?\") ? topic : topic + \"?\";\n\n        for (let key in this.subscriptions) {\n            if ((key + \"?\").startsWith(topic)) {\n                result[key] = this.subscriptions[key];\n            }\n        }\n\n        return result;\n    }\n\n    private getNonEmptySubscriptionKeys(): Array<string> {\n        const result: Array<string> = [];\n\n        for (let key in this.subscriptions) {\n            if (this.subscriptions[key].length) {\n                result.push(key);\n            }\n        }\n\n        return result;\n    }\n\n    private addAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        this.removeAllSubscriptionListeners();\n\n        for (let key in this.subscriptions) {\n            for (let listener of this.subscriptions[key]) {\n                this.eventSource.addEventListener(key, listener);\n            }\n        }\n    }\n\n    private removeAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        for (let key in this.subscriptions) {\n            for (let listener of this.subscriptions[key]) {\n                this.eventSource.removeEventListener(key, listener);\n            }\n        }\n    }\n\n    private async connect(): Promise<void> {\n        if (this.reconnectAttempts > 0) {\n            // immediately resolve the promise to avoid indefinitely\n            // blocking the client during reconnection\n            return;\n        }\n\n        return new Promise((resolve, reject) => {\n            this.pendingConnects.push({ resolve, reject });\n\n            if (this.pendingConnects.length > 1) {\n                // all promises will be resolved once the connection is established\n                return;\n            }\n\n            this.initConnect();\n        });\n    }\n\n    private initConnect() {\n        this.disconnect(true);\n\n        // wait up to 15s for connect\n        clearTimeout(this.connectTimeoutId);\n        this.connectTimeoutId = setTimeout(() => {\n            this.connectErrorHandler(new Error(\"EventSource connect took too long.\"));\n        }, this.maxConnectTimeout);\n\n        this.eventSource = new EventSource(this.client.buildURL(\"/api/realtime\"));\n\n        this.eventSource.onerror = (_) => {\n            this.connectErrorHandler(\n                new Error(\"Failed to establish realtime connection.\"),\n            );\n        };\n\n        this.eventSource.addEventListener(\"PB_CONNECT\", (e) => {\n            const msgEvent = e as MessageEvent;\n            this.clientId = msgEvent?.lastEventId;\n\n            this.submitSubscriptions()\n                .then(async () => {\n                    let retries = 3;\n                    while (this.hasUnsentSubscriptions() && retries > 0) {\n                        retries--;\n                        // resubscribe to ensure that the latest topics are submitted\n                        //\n                        // This is needed because missed topics could happen on reconnect\n                        // if after the pending sent `submitSubscriptions()` call another `subscribe()`\n                        // was made before the submit was able to complete.\n                        await this.submitSubscriptions();\n                    }\n                })\n                .then(() => {\n                    for (let p of this.pendingConnects) {\n                        p.resolve();\n                    }\n\n                    // reset connect meta\n                    this.pendingConnects = [];\n                    this.reconnectAttempts = 0;\n                    clearTimeout(this.reconnectTimeoutId);\n                    clearTimeout(this.connectTimeoutId);\n\n                    // propagate the PB_CONNECT event\n                    const connectSubs = this.getSubscriptionsByTopic(\"PB_CONNECT\");\n                    for (let key in connectSubs) {\n                        for (let listener of connectSubs[key]) {\n                            listener(e);\n                        }\n                    }\n                })\n                .catch((err) => {\n                    this.clientId = \"\";\n                    this.connectErrorHandler(err);\n                });\n        });\n    }\n\n    private hasUnsentSubscriptions(): boolean {\n        const latestTopics = this.getNonEmptySubscriptionKeys();\n        if (latestTopics.length != this.lastSentSubscriptions.length) {\n            return true;\n        }\n\n        for (const t of latestTopics) {\n            if (!this.lastSentSubscriptions.includes(t)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private connectErrorHandler(err: any) {\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n\n        if (\n            // wasn't previously connected -> direct reject\n            (!this.clientId && !this.reconnectAttempts) ||\n            // was previously connected but the max reconnection limit has been reached\n            this.reconnectAttempts > this.maxReconnectAttempts\n        ) {\n            for (let p of this.pendingConnects) {\n                p.reject(new ClientResponseError(err));\n            }\n            this.pendingConnects = [];\n            this.disconnect();\n            return;\n        }\n\n        // otherwise -> reconnect in the background\n        this.disconnect(true);\n        const timeout =\n            this.predefinedReconnectIntervals[this.reconnectAttempts] ||\n            this.predefinedReconnectIntervals[\n                this.predefinedReconnectIntervals.length - 1\n            ];\n        this.reconnectAttempts++;\n        this.reconnectTimeoutId = setTimeout(() => {\n            this.initConnect();\n        }, timeout);\n    }\n\n    private disconnect(fromReconnect = false): void {\n        if (this.clientId && this.onDisconnect) {\n            this.onDisconnect(Object.keys(this.subscriptions));\n        }\n\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n        this.removeAllSubscriptionListeners();\n        this.client.cancelRequest(this.getSubscriptionsCancelKey());\n        this.eventSource?.close();\n        this.eventSource = null;\n        this.clientId = \"\";\n\n        if (!fromReconnect) {\n            this.reconnectAttempts = 0;\n\n            // resolve any remaining connect promises\n            //\n            // this is done to avoid unnecessary throwing errors in case\n            // unsubscribe is called before the pending connect promises complete\n            // (see https://github.com/pocketbase/pocketbase/discussions/2897#discussioncomment-6423818)\n            for (let p of this.pendingConnects) {\n                p.resolve();\n            }\n            this.pendingConnects = [];\n        }\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { ClientResponseError } from \"@/ClientResponseError\";\nimport { ListResult } from \"@/tools/dtos\";\nimport { CommonOptions, ListOptions, FullListOptions } from \"@/tools/options\";\n\nexport abstract class CrudService<M> extends BaseService {\n    /**\n     * Base path for the crud actions (without trailing slash, eg. '/admins').\n     */\n    abstract get baseCrudPath(): string;\n\n    /**\n     * Response data decoder.\n     */\n    decode<T = M>(data: { [key: string]: any }): T {\n        return data as T;\n    }\n\n    /**\n     * Returns a promise with all list items batch fetched at once\n     * (by default 500 items per request; to change it set the `batch` query param).\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFullList<T = M>(options?: FullListOptions): Promise<Array<T>>;\n\n    /**\n     * Legacy version of getFullList with explicitly specified batch size.\n     */\n    async getFullList<T = M>(batch?: number, options?: ListOptions): Promise<Array<T>>;\n\n    async getFullList<T = M>(\n        batchOrqueryParams?: number | FullListOptions,\n        options?: ListOptions,\n    ): Promise<Array<T>> {\n        if (typeof batchOrqueryParams == \"number\") {\n            return this._getFullList<T>(batchOrqueryParams, options);\n        }\n\n        options = Object.assign({}, batchOrqueryParams, options);\n\n        let batch = 500;\n        if (options.batch) {\n            batch = options.batch;\n            delete options.batch;\n        }\n\n        return this._getFullList<T>(batch, options);\n    }\n\n    /**\n     * Returns paginated items list.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getList<T = M>(\n        page = 1,\n        perPage = 30,\n        options?: ListOptions,\n    ): Promise<ListResult<T>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        options.query = Object.assign(\n            {\n                page: page,\n                perPage: perPage,\n            },\n            options.query,\n        );\n\n        return this.client.send(this.baseCrudPath, options).then((responseData: any) => {\n            responseData.items =\n                responseData.items?.map((item: any) => {\n                    return this.decode<T>(item);\n                }) || [];\n\n            return responseData;\n        });\n    }\n\n    /**\n     * Returns the first found item by the specified filter.\n     *\n     * Internally it calls `getList(1, 1, { filter, skipTotal })` and\n     * returns the first found item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * For consistency with `getOne`, this method will throw a 404\n     * ClientResponseError if no item was found.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFirstListItem<T = M>(filter: string, options?: CommonOptions): Promise<T> {\n        options = Object.assign(\n            {\n                requestKey: \"one_by_filter_\" + this.baseCrudPath + \"_\" + filter,\n            },\n            options,\n        );\n\n        options.query = Object.assign(\n            {\n                filter: filter,\n                skipTotal: 1,\n            },\n            options.query,\n        );\n\n        return this.getList<T>(1, 1, options).then((result) => {\n            if (!result?.items?.length) {\n                throw new ClientResponseError({\n                    status: 404,\n                    response: {\n                        code: 404,\n                        message: \"The requested resource wasn't found.\",\n                        data: {},\n                    },\n                });\n            }\n\n            return result.items[0];\n        });\n    }\n\n    /**\n     * Returns single item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * If `id` is empty it will throw a 404 error.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getOne<T = M>(id: string, options?: CommonOptions): Promise<T> {\n        if (!id) {\n            throw new ClientResponseError({\n                url: this.client.buildURL(this.baseCrudPath + \"/\"),\n                status: 404,\n                response: {\n                    code: 404,\n                    message: \"Missing required record id.\",\n                    data: {},\n                },\n            });\n        }\n\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Creates a new item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async create<T = M>(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<T> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath, options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Updates an existing item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async update<T = M>(\n        id: string,\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<T> {\n        options = Object.assign(\n            {\n                method: \"PATCH\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Deletes an existing item by its id.\n     *\n     * @throws {ClientResponseError}\n     */\n    async delete(id: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"DELETE\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\n            .then(() => true);\n    }\n\n    /**\n     * Returns a promise with all list items batch fetched at once.\n     */\n    protected _getFullList<T = M>(\n        batchSize = 500,\n        options?: ListOptions,\n    ): Promise<Array<T>> {\n        options = options || {};\n        options.query = Object.assign(\n            {\n                skipTotal: 1,\n            },\n            options.query,\n        );\n\n        let result: Array<T> = [];\n\n        let request = async (page: number): Promise<Array<any>> => {\n            return this.getList(page, batchSize || 500, options).then((list) => {\n                const castedList = list as any as ListResult<T>;\n                const items = castedList.items;\n\n                result = result.concat(items);\n\n                if (items.length == list.perPage) {\n                    return request(page + 1);\n                }\n\n                return result;\n            });\n        };\n\n        return request(1);\n    }\n}\n","import { SendOptions } from \"@/tools/options\";\n\nexport function normalizeLegacyOptionsArgs(\n    legacyWarn: string,\n    baseOptions: SendOptions,\n    bodyOrOptions?: any,\n    query?: any,\n): SendOptions {\n    const hasBodyOrOptions = typeof bodyOrOptions !== \"undefined\";\n    const hasQuery = typeof query !== \"undefined\";\n\n    if (!hasQuery && !hasBodyOrOptions) {\n        return baseOptions;\n    }\n\n    if (hasQuery) {\n        console.warn(legacyWarn);\n        baseOptions.body = Object.assign({}, baseOptions.body, bodyOrOptions);\n        baseOptions.query = Object.assign({}, baseOptions.query, query);\n\n        return baseOptions;\n    }\n\n    return Object.assign(baseOptions, bodyOrOptions);\n}\n","import Client from \"@/Client\";\nimport { isTokenExpired } from \"@/tools/jwt\";\n\n// reset previous auto refresh registrations\nexport function resetAutoRefresh(client: Client) {\n    (client as any)._resetAutoRefresh?.();\n}\n\nexport function registerAutoRefresh(\n    client: Client,\n    threshold: number,\n    refreshFunc: () => Promise<any>,\n    reauthenticateFunc: () => Promise<any>,\n) {\n    resetAutoRefresh(client);\n\n    const oldBeforeSend = client.beforeSend;\n    const oldModel = client.authStore.record;\n\n    // unset the auto refresh in case the auth store was cleared\n    // OR a new model was authenticated\n    const unsubStoreChange = client.authStore.onChange((newToken, model) => {\n        if (\n            !newToken ||\n            model?.id != oldModel?.id ||\n            ((model?.collectionId || oldModel?.collectionId) &&\n                model?.collectionId != oldModel?.collectionId)\n        ) {\n            resetAutoRefresh(client);\n        }\n    });\n\n    // initialize a reset function and attach it dynamically to the client\n    (client as any)._resetAutoRefresh = function () {\n        unsubStoreChange();\n        client.beforeSend = oldBeforeSend;\n        delete (client as any)._resetAutoRefresh;\n    };\n\n    client.beforeSend = async (url, sendOptions) => {\n        const oldToken = client.authStore.token;\n\n        if (sendOptions.query?.autoRefresh) {\n            return oldBeforeSend ? oldBeforeSend(url, sendOptions) : { url, sendOptions };\n        }\n\n        let isValid = client.authStore.isValid;\n        if (\n            // is loosely valid\n            isValid &&\n            // but it is going to expire in the next \"threshold\" seconds\n            isTokenExpired(client.authStore.token, threshold)\n        ) {\n            try {\n                await refreshFunc();\n            } catch (_) {\n                isValid = false;\n            }\n        }\n\n        // still invalid -> reauthenticate\n        if (!isValid) {\n            await reauthenticateFunc();\n        }\n\n        // the request wasn't sent with a custom token\n        const headers = sendOptions.headers || {};\n        for (let key in headers) {\n            if (\n                key.toLowerCase() == \"authorization\" &&\n                // the request wasn't sent with a custom token\n                oldToken == headers[key] &&\n                client.authStore.token\n            ) {\n                // set the latest store token\n                headers[key] = client.authStore.token;\n                break;\n            }\n        }\n        sendOptions.headers = headers;\n\n        return oldBeforeSend ? oldBeforeSend(url, sendOptions) : { url, sendOptions };\n    };\n}\n","import Client from \"@/Client\";\nimport { ClientResponseError } from \"@/ClientResponseError\";\nimport { RealtimeService, UnsubscribeFunc } from \"@/services/RealtimeService\";\nimport { BaseAuthStore } from \"@/stores/BaseAuthStore\";\nimport { CrudService } from \"@/services/CrudService\";\nimport { ListResult, RecordModel } from \"@/tools/dtos\";\nimport { normalizeLegacyOptionsArgs } from \"@/tools/legacy\";\nimport {\n    CommonOptions,\n    RecordFullListOptions,\n    RecordListOptions,\n    RecordOptions,\n    SendOptions,\n    RecordSubscribeOptions,\n} from \"@/tools/options\";\nimport { getTokenPayload } from \"@/tools/jwt\";\nimport { registerAutoRefresh, resetAutoRefresh } from \"@/tools/refresh\";\n\nexport interface RecordAuthResponse<T = RecordModel> {\n    /**\n     * The signed PocketBase auth record.\n     */\n    record: T;\n\n    /**\n     * The PocketBase record auth token.\n     *\n     * If you are looking for the OAuth2 access and refresh tokens\n     * they are available under the `meta.accessToken` and `meta.refreshToken` props.\n     */\n    token: string;\n\n    /**\n     * Auth meta data usually filled when OAuth2 is used.\n     */\n    meta?: { [key: string]: any };\n}\n\nexport interface AuthProviderInfo {\n    name: string;\n    displayName: string;\n    state: string;\n    authURL: string;\n    codeVerifier: string;\n    codeChallenge: string;\n    codeChallengeMethod: string;\n}\n\nexport interface AuthMethodsList {\n    mfa: {\n        enabled: boolean;\n        duration: number;\n    };\n    otp: {\n        enabled: boolean;\n        duration: number;\n    };\n    password: {\n        enabled: boolean;\n        identityFields: Array<string>;\n    };\n    oauth2: {\n        enabled: boolean;\n        providers: Array<AuthProviderInfo>;\n    };\n}\n\nexport interface RecordSubscription<T = RecordModel> {\n    action: string; // eg. create, update, delete\n    record: T;\n}\n\nexport type OAuth2UrlCallback = (url: string) => void | Promise<void>;\n\nexport interface OAuth2AuthConfig extends SendOptions {\n    // the name of the OAuth2 provider (eg. \"google\")\n    provider: string;\n\n    // custom scopes to overwrite the default ones\n    scopes?: Array<string>;\n\n    // optional record create data\n    createData?: { [key: string]: any };\n\n    // optional callback that is triggered after the OAuth2 sign-in/sign-up url generation\n    urlCallback?: OAuth2UrlCallback;\n\n    // optional query params to send with the PocketBase auth request (eg. fields, expand, etc.)\n    query?: RecordOptions;\n}\n\nexport interface OTPResponse {\n    otpId: string;\n}\n\nexport class RecordService<M = RecordModel> extends CrudService<M> {\n    readonly collectionIdOrName: string;\n\n    constructor(client: Client, collectionIdOrName: string) {\n        super(client);\n\n        this.collectionIdOrName = collectionIdOrName;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return this.baseCollectionPath + \"/records\";\n    }\n\n    /**\n     * Returns the current collection service base path.\n     */\n    get baseCollectionPath(): string {\n        return \"/api/collections/\" + encodeURIComponent(this.collectionIdOrName);\n    }\n\n    /**\n     * Returns whether the current service collection is superusers.\n     */\n    get isSuperusers(): boolean {\n        return (\n            this.collectionIdOrName == \"_superusers\" ||\n            this.collectionIdOrName == \"_pbc_2773867675\"\n        );\n    }\n\n    // ---------------------------------------------------------------\n    // Realtime handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Subscribe to realtime changes to the specified topic (\"*\" or record id).\n     *\n     * If `topic` is the wildcard \"*\", then this method will subscribe to\n     * any record changes in the collection.\n     *\n     * If `topic` is a record id, then this method will subscribe only\n     * to changes of the specified record id.\n     *\n     * It's OK to subscribe multiple times to the same topic.\n     * You can use the returned `UnsubscribeFunc` to remove only a single subscription.\n     * Or use `unsubscribe(topic)` if you want to remove all subscriptions attached to the topic.\n     */\n    async subscribe<T = M>(\n        topic: string,\n        callback: (data: RecordSubscription<T>) => void,\n        options?: RecordSubscribeOptions,\n    ): Promise<UnsubscribeFunc> {\n        if (!topic) {\n            throw new Error(\"Missing topic.\");\n        }\n\n        if (!callback) {\n            throw new Error(\"Missing subscription callback.\");\n        }\n\n        return this.client.realtime.subscribe(\n            this.collectionIdOrName + \"/\" + topic,\n            callback,\n            options,\n        );\n    }\n\n    /**\n     * Unsubscribe from all subscriptions of the specified topic\n     * (\"*\" or record id).\n     *\n     * If `topic` is not set, then this method will unsubscribe from\n     * all subscriptions associated to the current collection.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        // unsubscribe from the specified topic\n        if (topic) {\n            return this.client.realtime.unsubscribe(\n                this.collectionIdOrName + \"/\" + topic,\n            );\n        }\n\n        // unsubscribe from everything related to the collection\n        return this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName);\n    }\n\n    // ---------------------------------------------------------------\n    // Crud handers\n    // ---------------------------------------------------------------\n    /**\n     * @inheritdoc\n     */\n    async getFullList<T = M>(options?: RecordFullListOptions): Promise<Array<T>>;\n\n    /**\n     * @inheritdoc\n     */\n    async getFullList<T = M>(\n        batch?: number,\n        options?: RecordListOptions,\n    ): Promise<Array<T>>;\n\n    /**\n     * @inheritdoc\n     */\n    async getFullList<T = M>(\n        batchOrOptions?: number | RecordFullListOptions,\n        options?: RecordListOptions,\n    ): Promise<Array<T>> {\n        if (typeof batchOrOptions == \"number\") {\n            return super.getFullList<T>(batchOrOptions, options);\n        }\n\n        const params = Object.assign({}, batchOrOptions, options);\n\n        return super.getFullList<T>(params);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getList<T = M>(\n        page = 1,\n        perPage = 30,\n        options?: RecordListOptions,\n    ): Promise<ListResult<T>> {\n        return super.getList<T>(page, perPage, options);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getFirstListItem<T = M>(\n        filter: string,\n        options?: RecordListOptions,\n    ): Promise<T> {\n        return super.getFirstListItem<T>(filter, options);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async getOne<T = M>(id: string, options?: RecordOptions): Promise<T> {\n        return super.getOne<T>(id, options);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    async create<T = M>(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): Promise<T> {\n        return super.create<T>(bodyParams, options);\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.record` matches with the updated id, then\n     * on success the `client.authStore.record` will be updated with the new response record fields.\n     */\n    async update<T = M>(\n        id: string,\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): Promise<T> {\n        return super.update<RecordModel>(id, bodyParams, options).then((item) => {\n            if (\n                // is record auth\n                this.client.authStore.record?.id === item?.id &&\n                (this.client.authStore.record?.collectionId === this.collectionIdOrName ||\n                    this.client.authStore.record?.collectionName ===\n                        this.collectionIdOrName)\n            ) {\n                let authExpand = Object.assign({}, this.client.authStore.record.expand);\n                let authRecord = Object.assign({}, this.client.authStore.record, item);\n                if (authExpand) {\n                    // for now \"merge\" only top-level expand\n                    authRecord.expand = Object.assign(authExpand, item.expand);\n                }\n\n                this.client.authStore.save(this.client.authStore.token, authRecord);\n            }\n\n            return item as any as T;\n        });\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.record` matches with the deleted id,\n     * then on success the `client.authStore` will be cleared.\n     */\n    async delete(id: string, options?: CommonOptions): Promise<boolean> {\n        return super.delete(id, options).then((success) => {\n            if (\n                success &&\n                // is record auth\n                this.client.authStore.record?.id === id &&\n                (this.client.authStore.record?.collectionId === this.collectionIdOrName ||\n                    this.client.authStore.record?.collectionName ===\n                        this.collectionIdOrName)\n            ) {\n                this.client.authStore.clear();\n            }\n\n            return success;\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Auth handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Prepare successful collection authorization response.\n     */\n    protected authResponse<T = M>(responseData: any): RecordAuthResponse<T> {\n        const record = this.decode(responseData?.record || {});\n\n        this.client.authStore.save(responseData?.token, record as any);\n\n        return Object.assign({}, responseData, {\n            // normalize common fields\n            token: responseData?.token || \"\",\n            record: record as any as T,\n        });\n    }\n\n    /**\n     * Returns all available collection auth methods.\n     *\n     * @throws {ClientResponseError}\n     */\n    async listAuthMethods(options?: CommonOptions): Promise<AuthMethodsList> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n                // @todo remove after deleting the pre v0.23 API response fields\n                fields: \"mfa,otp,password,oauth2\",\n            },\n            options,\n        );\n\n        return this.client.send(this.baseCollectionPath + \"/auth-methods\", options);\n    }\n\n    /**\n     * Authenticate a single auth collection record via its username/email and password.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithPassword<T = M>(\n        usernameOrEmail: string,\n        password: string,\n        options?: RecordOptions,\n    ): Promise<RecordAuthResponse<T>> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    identity: usernameOrEmail,\n                    password: password,\n                },\n            },\n            options,\n        );\n\n        // note: consider to deprecate\n        let autoRefreshThreshold;\n        if (this.isSuperusers) {\n            autoRefreshThreshold = options.autoRefreshThreshold;\n            delete options.autoRefreshThreshold;\n            if (!options.autoRefresh) {\n                resetAutoRefresh(this.client);\n            }\n        }\n\n        let authData = await this.client.send(\n            this.baseCollectionPath + \"/auth-with-password\",\n            options,\n        );\n\n        authData = this.authResponse<T>(authData);\n\n        if (autoRefreshThreshold && this.isSuperusers) {\n            registerAutoRefresh(\n                this.client,\n                autoRefreshThreshold,\n                () => this.authRefresh({ autoRefresh: true }),\n                () =>\n                    this.authWithPassword<T>(\n                        usernameOrEmail,\n                        password,\n                        Object.assign({ autoRefresh: true }, options),\n                    ),\n            );\n        }\n\n        return authData;\n    }\n\n    /**\n     * Authenticate a single auth collection record with OAuth2 code.\n     *\n     * If you don't have an OAuth2 code you may also want to check `authWithOAuth2` method.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithOAuth2Code<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectURL: string,\n        createData?: { [key: string]: any },\n        options?: RecordOptions,\n    ): Promise<RecordAuthResponse<T>>;\n\n    /**\n     * @deprecated\n     * Consider using authWithOAuth2Code(provider, code, codeVerifier, redirectURL, createdData, options?).\n     */\n    async authWithOAuth2Code<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectURL: string,\n        createData?: { [key: string]: any },\n        body?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>>;\n\n    async authWithOAuth2Code<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectURL: string,\n        createData?: { [key: string]: any },\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                provider: provider,\n                code: code,\n                codeVerifier: codeVerifier,\n                redirectURL: redirectURL,\n                createData: createData,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of authWithOAuth2Code(provider, code, codeVerifier, redirectURL, createData?, body?, query?) is deprecated. Consider replacing it with authWithOAuth2Code(provider, code, codeVerifier, redirectURL, createData?, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/auth-with-oauth2\", options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * @deprecated This form of authWithOAuth2 is deprecated.\n     *\n     * Please use `authWithOAuth2Code()` OR its simplified realtime version\n     * as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\n     */\n    async authWithOAuth2<T = M>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectURL: string,\n        createData?: { [key: string]: any },\n        bodyParams?: { [key: string]: any },\n        queryParams?: RecordOptions,\n    ): Promise<RecordAuthResponse<T>>;\n\n    /**\n     * Authenticate a single auth collection record with OAuth2\n     * **without custom redirects, deeplinks or even page reload**.\n     *\n     * This method initializes a one-off realtime subscription and will\n     * open a popup window with the OAuth2 vendor page to authenticate.\n     * Once the external OAuth2 sign-in/sign-up flow is completed, the popup\n     * window will be automatically closed and the OAuth2 data sent back\n     * to the user through the previously established realtime connection.\n     *\n     * You can specify an optional `urlCallback` prop to customize\n     * the default url `window.open` behavior.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     *\n     * Example:\n     *\n     * ```js\n     * const authData = await pb.collection(\"users\").authWithOAuth2({\n     *     provider: \"google\",\n     * })\n     * ```\n     *\n     * Note1: When creating the OAuth2 app in the provider dashboard\n     * you have to configure `https://yourdomain.com/api/oauth2-redirect`\n     * as redirect URL.\n     *\n     * Note2: Safari may block the default `urlCallback` popup because\n     * it doesn't allow `window.open` calls as part of an `async` click functions.\n     * To workaround this you can either change your click handler to not be marked as `async`\n     * OR manually call `window.open` before your `async` function and use the\n     * window reference in your own custom `urlCallback` (see https://github.com/pocketbase/pocketbase/discussions/2429#discussioncomment-5943061).\n     * For example:\n     * ```js\n     * <button id=\"btn\">Login with Gitlab</button>\n     * ...\n     * document.getElementById(\"btn\").addEventListener(\"click\", () => {\n     *     pb.collection(\"users\").authWithOAuth2({\n     *         provider: \"gitlab\",\n     *     }).then((authData) => {\n     *         console.log(authData)\n     *     }).catch((err) => {\n     *         console.log(err, err.originalError);\n     *     });\n     * })\n     * ```\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithOAuth2<T = M>(\n        options: OAuth2AuthConfig,\n    ): Promise<RecordAuthResponse<T>>;\n\n    authWithOAuth2<T = M>(...args: any): Promise<RecordAuthResponse<T>> {\n        // fallback to legacy format\n        if (args.length > 1 || typeof args?.[0] === \"string\") {\n            console.warn(\n                \"PocketBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\",\n            );\n            return this.authWithOAuth2Code<T>(\n                args?.[0] || \"\",\n                args?.[1] || \"\",\n                args?.[2] || \"\",\n                args?.[3] || \"\",\n                args?.[4] || {},\n                args?.[5] || {},\n                args?.[6] || {},\n            );\n        }\n\n        const config = args?.[0] || {};\n\n        // open a new popup window in case config.urlCallback is not set\n        //\n        // note: it is opened before any async calls due to Safari restrictions\n        // (see https://github.com/pocketbase/pocketbase/discussions/2429#discussioncomment-5943061)\n        let eagerDefaultPopup: Window | null = null;\n        if (!config.urlCallback) {\n            eagerDefaultPopup = openBrowserPopup(undefined);\n        }\n\n        // initialize a one-off realtime service\n        const realtime = new RealtimeService(this.client);\n\n        function cleanup() {\n            eagerDefaultPopup?.close();\n            realtime.unsubscribe();\n        }\n\n        const requestKeyOptions: SendOptions = {};\n        const requestKey = config.requestKey;\n        if (requestKey) {\n            requestKeyOptions.requestKey = requestKey;\n        }\n\n        return this.listAuthMethods(requestKeyOptions)\n            .then((authMethods) => {\n                const provider = authMethods.oauth2.providers.find(\n                    (p) => p.name === config.provider,\n                );\n                if (!provider) {\n                    throw new ClientResponseError(\n                        new Error(`Missing or invalid provider \"${config.provider}\".`),\n                    );\n                }\n\n                const redirectURL = this.client.buildURL(\"/api/oauth2-redirect\");\n\n                // find the AbortController associated with the current request key (if any)\n                const cancelController = requestKey\n                    ? this.client[\"cancelControllers\"]?.[requestKey]\n                    : undefined;\n                if (cancelController) {\n                    cancelController.signal.onabort = () => {\n                        cleanup();\n                    };\n                }\n\n                return new Promise(async (resolve, reject) => {\n                    try {\n                        await realtime.subscribe(\"@oauth2\", async (e) => {\n                            const oldState = realtime.clientId;\n\n                            try {\n                                if (!e.state || oldState !== e.state) {\n                                    throw new Error(\"State parameters don't match.\");\n                                }\n\n                                if (e.error || !e.code) {\n                                    throw new Error(\n                                        \"OAuth2 redirect error or missing code: \" +\n                                            e.error,\n                                    );\n                                }\n\n                                // clear the non SendOptions props\n                                const options = Object.assign({}, config);\n                                delete options.provider;\n                                delete options.scopes;\n                                delete options.createData;\n                                delete options.urlCallback;\n\n                                // reset the cancelController listener as it will be triggered by the next api call\n                                if (cancelController?.signal?.onabort) {\n                                    cancelController.signal.onabort = null;\n                                }\n\n                                const authData = await this.authWithOAuth2Code<T>(\n                                    provider.name,\n                                    e.code,\n                                    provider.codeVerifier,\n                                    redirectURL,\n                                    config.createData,\n                                    options,\n                                );\n\n                                resolve(authData);\n                            } catch (err) {\n                                reject(new ClientResponseError(err));\n                            }\n\n                            cleanup();\n                        });\n\n                        const replacements: { [key: string]: any } = {\n                            state: realtime.clientId,\n                        };\n                        if (config.scopes?.length) {\n                            replacements[\"scope\"] = config.scopes.join(\" \");\n                        }\n\n                        const url = this._replaceQueryParams(\n                            provider.authURL + redirectURL,\n                            replacements,\n                        );\n\n                        let urlCallback =\n                            config.urlCallback ||\n                            function (url: string) {\n                                if (eagerDefaultPopup) {\n                                    eagerDefaultPopup.location.href = url;\n                                } else {\n                                    // it could have been blocked due to its empty initial url,\n                                    // try again...\n                                    eagerDefaultPopup = openBrowserPopup(url);\n                                }\n                            };\n\n                        await urlCallback(url);\n                    } catch (err) {\n                        cleanup();\n                        reject(new ClientResponseError(err));\n                    }\n                });\n            })\n            .catch((err) => {\n                cleanup();\n                throw err; // rethrow\n            }) as Promise<RecordAuthResponse<T>>;\n    }\n\n    /**\n     * Refreshes the current authenticated record instance and\n     * returns a new token and record data.\n     *\n     * On success this method also automatically updates the client's AuthStore.\n     *\n     * @throws {ClientResponseError}\n     */\n    async authRefresh<T = M>(options?: RecordOptions): Promise<RecordAuthResponse<T>>;\n\n    /**\n     * @deprecated\n     * Consider using authRefresh(options?).\n     */\n    async authRefresh<T = M>(body?: any, query?: any): Promise<RecordAuthResponse<T>>;\n\n    async authRefresh<T = M>(\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<RecordAuthResponse<T>> {\n        let options: any = {\n            method: \"POST\",\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/auth-refresh\", options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Sends auth record password reset request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestPasswordReset(email: string, options?: CommonOptions): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using requestPasswordReset(email, options?).\n     */\n    async requestPasswordReset(email: string, body?: any, query?: any): Promise<boolean>;\n\n    async requestPasswordReset(\n        email: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                email: email,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/request-password-reset\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms auth record password reset request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        options?: CommonOptions,\n    ): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using confirmPasswordReset(passwordResetToken, password, passwordConfirm, options?).\n     */\n    async confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>;\n\n    async confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                token: passwordResetToken,\n                password: password,\n                passwordConfirm: passwordConfirm,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of confirmPasswordReset(token, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(token, password, passwordConfirm, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/confirm-password-reset\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Sends auth record verification email request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestVerification(email: string, options?: CommonOptions): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using requestVerification(email, options?).\n     */\n    async requestVerification(email: string, body?: any, query?: any): Promise<boolean>;\n\n    async requestVerification(\n        email: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                email: email,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of requestVerification(email, body?, query?) is deprecated. Consider replacing it with requestVerification(email, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/request-verification\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms auth record email verification request.\n     *\n     * If the current `client.authStore.record` matches with the auth record from the token,\n     * then on success the `client.authStore.record.verified` will be updated to `true`.\n     *\n     * @throws {ClientResponseError}\n     */\n    async confirmVerification(\n        verificationToken: string,\n        options?: CommonOptions,\n    ): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using confirmVerification(verificationToken, options?).\n     */\n    async confirmVerification(\n        verificationToken: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>;\n\n    async confirmVerification(\n        verificationToken: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                token: verificationToken,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of confirmVerification(token, body?, query?) is deprecated. Consider replacing it with confirmVerification(token, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/confirm-verification\", options)\n            .then(() => {\n                // on success manually update the current auth record verified state\n                const payload = getTokenPayload(verificationToken);\n                const model = this.client.authStore.record;\n                if (\n                    model &&\n                    !model.verified &&\n                    model.id === payload.id &&\n                    model.collectionId === payload.collectionId\n                ) {\n                    model.verified = true;\n                    this.client.authStore.save(this.client.authStore.token, model);\n                }\n\n                return true;\n            });\n    }\n\n    /**\n     * Sends an email change request to the authenticated record model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestEmailChange(newEmail: string, options?: CommonOptions): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using requestEmailChange(newEmail, options?).\n     */\n    async requestEmailChange(newEmail: string, body?: any, query?: any): Promise<boolean>;\n\n    async requestEmailChange(\n        newEmail: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                newEmail: newEmail,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of requestEmailChange(newEmail, body?, query?) is deprecated. Consider replacing it with requestEmailChange(newEmail, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/request-email-change\", options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms auth record's new email address.\n     *\n     * If the current `client.authStore.record` matches with the auth record from the token,\n     * then on success the `client.authStore` will be cleared.\n     *\n     * @throws {ClientResponseError}\n     */\n    async confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        options?: CommonOptions,\n    ): Promise<boolean>;\n\n    /**\n     * @deprecated\n     * Consider using confirmEmailChange(emailChangeToken, password, options?).\n     */\n    async confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>;\n\n    async confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            method: \"POST\",\n            body: {\n                token: emailChangeToken,\n                password: password,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            \"This form of confirmEmailChange(token, password, body?, query?) is deprecated. Consider replacing it with confirmEmailChange(token, password, options?).\",\n            options,\n            bodyOrOptions,\n            query,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/confirm-email-change\", options)\n            .then(() => {\n                const payload = getTokenPayload(emailChangeToken);\n                const model = this.client.authStore.record;\n                if (\n                    model &&\n                    model.id === payload.id &&\n                    model.collectionId === payload.collectionId\n                ) {\n                    this.client.authStore.clear();\n                }\n\n                return true;\n            });\n    }\n\n    /**\n     * @deprecated use collection(\"_externalAuths\").*\n     *\n     * Lists all linked external auth providers for the specified auth record.\n     *\n     * @throws {ClientResponseError}\n     */\n    async listExternalAuths(\n        recordId: string,\n        options?: CommonOptions,\n    ): Promise<Array<RecordModel>> {\n        return this.client.collection(\"_externalAuths\").getFullList(\n            Object.assign({}, options, {\n                filter: this.client.filter(\"recordRef = {:id}\", { id: recordId }),\n            }),\n        );\n    }\n\n    /**\n     * @deprecated use collection(\"_externalAuths\").*\n     *\n     * Unlink a single external auth provider from the specified auth record.\n     *\n     * @throws {ClientResponseError}\n     */\n    async unlinkExternalAuth(\n        recordId: string,\n        provider: string,\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        const ea = await this.client.collection(\"_externalAuths\").getFirstListItem(\n            this.client.filter(\"recordRef = {:recordId} && provider = {:provider}\", {\n                recordId,\n                provider,\n            }),\n        );\n\n        return this.client\n            .collection(\"_externalAuths\")\n            .delete(ea.id, options)\n            .then(() => true);\n    }\n\n    /**\n     * Sends auth record OTP to the provided email.\n     *\n     * @throws {ClientResponseError}\n     */\n    async requestOTP(email: string, options?: CommonOptions): Promise<OTPResponse> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: { email: email },\n            },\n            options,\n        );\n\n        return this.client.send(this.baseCollectionPath + \"/request-otp\", options);\n    }\n\n    /**\n     * Authenticate a single auth collection record via OTP.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     *\n     * @throws {ClientResponseError}\n     */\n    async authWithOTP<T = M>(\n        otpId: string,\n        password: string,\n        options?: CommonOptions,\n    ): Promise<RecordAuthResponse<T>> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: { otpId, password },\n            },\n            options,\n        );\n\n        return this.client\n            .send(this.baseCollectionPath + \"/auth-with-otp\", options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Impersonate authenticates with the specified recordId and\n     * returns a new client with the received auth token in a memory store.\n     *\n     * If `duration` is 0 the generated auth token will fallback\n     * to the default collection auth token duration.\n     *\n     * This action currently requires superusers privileges.\n     *\n     * @throws {ClientResponseError}\n     */\n    async impersonate(\n        recordId: string,\n        duration: number,\n        options?: CommonOptions,\n    ): Promise<Client> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: { duration: duration },\n            },\n            options,\n        );\n        options.headers = options.headers || {};\n        if (!options.headers.Authorization) {\n            options.headers.Authorization = this.client.authStore.token;\n        }\n\n        // create a new client loaded with the impersonated auth state\n        // ---\n        const client = new Client(\n            this.client.baseURL,\n            new BaseAuthStore(),\n            this.client.lang,\n        );\n\n        const authData = await client.send(\n            this.baseCollectionPath + \"/impersonate/\" + encodeURIComponent(recordId),\n            options,\n        );\n\n        client.authStore.save(authData?.token, this.decode(authData?.record || {}));\n        // ---\n\n        return client;\n    }\n\n    // ---------------------------------------------------------------\n\n    // very rudimentary url query params replacement because at the moment\n    // URL (and URLSearchParams) doesn't seem to be fully supported in React Native\n    //\n    // note: for details behind some of the decode/encode parsing check https://unixpapa.com/js/querystring.html\n    private _replaceQueryParams(\n        url: string,\n        replacements: { [key: string]: any } = {},\n    ): string {\n        let urlPath = url;\n        let query = \"\";\n\n        const queryIndex = url.indexOf(\"?\");\n        if (queryIndex >= 0) {\n            urlPath = url.substring(0, url.indexOf(\"?\"));\n            query = url.substring(url.indexOf(\"?\") + 1);\n        }\n\n        const parsedParams: { [key: string]: string } = {};\n\n        // parse the query parameters\n        const rawParams = query.split(\"&\");\n        for (const param of rawParams) {\n            if (param == \"\") {\n                continue;\n            }\n\n            const pair = param.split(\"=\");\n            parsedParams[decodeURIComponent(pair[0].replace(/\\+/g, \" \"))] =\n                decodeURIComponent((pair[1] || \"\").replace(/\\+/g, \" \"));\n        }\n\n        // apply the replacements\n        for (let key in replacements) {\n            if (!replacements.hasOwnProperty(key)) {\n                continue;\n            }\n\n            if (replacements[key] == null) {\n                delete parsedParams[key];\n            } else {\n                parsedParams[key] = replacements[key];\n            }\n        }\n\n        // construct back the full query string\n        query = \"\";\n        for (let key in parsedParams) {\n            if (!parsedParams.hasOwnProperty(key)) {\n                continue;\n            }\n\n            if (query != \"\") {\n                query += \"&\";\n            }\n\n            query +=\n                encodeURIComponent(key.replace(/%20/g, \"+\")) +\n                \"=\" +\n                encodeURIComponent(parsedParams[key].replace(/%20/g, \"+\"));\n        }\n\n        return query != \"\" ? urlPath + \"?\" + query : urlPath;\n    }\n}\n\nfunction openBrowserPopup(url?: string): Window | null {\n    if (typeof window === \"undefined\" || !window?.open) {\n        throw new ClientResponseError(\n            new Error(\n                `Not in a browser context - please pass a custom urlCallback function.`,\n            ),\n        );\n    }\n\n    let width = 1024;\n    let height = 768;\n\n    let windowWidth = window.innerWidth;\n    let windowHeight = window.innerHeight;\n\n    // normalize window size\n    width = width > windowWidth ? windowWidth : width;\n    height = height > windowHeight ? windowHeight : height;\n\n    let left = windowWidth / 2 - width / 2;\n    let top = windowHeight / 2 - height / 2;\n\n    // note: we don't use the noopener and noreferrer attributes since\n    // for some reason browser blocks such windows then url is undefined/blank\n    return window.open(\n        url,\n        \"popup_window\",\n        \"width=\" +\n            width +\n            \",height=\" +\n            height +\n            \",top=\" +\n            top +\n            \",left=\" +\n            left +\n            \",resizable,menubar=no\",\n    );\n}\n","import { CrudService } from \"@/services/CrudService\";\nimport { CollectionModel } from \"@/tools/dtos\";\nimport { CommonOptions } from \"@/tools/options\";\n\nexport class CollectionService extends CrudService<CollectionModel> {\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return \"/api/collections\";\n    }\n\n    /**\n     * Imports the provided collections.\n     *\n     * If `deleteMissing` is `true`, all local collections and their fields,\n     * that are not present in the imported configuration, WILL BE DELETED\n     * (including their related records data)!\n     *\n     * @throws {ClientResponseError}\n     */\n    async import(\n        collections: Array<CollectionModel>,\n        deleteMissing: boolean = false,\n        options?: CommonOptions,\n    ): Promise<true> {\n        options = Object.assign(\n            {\n                method: \"PUT\",\n                body: {\n                    collections: collections,\n                    deleteMissing: deleteMissing,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(this.baseCrudPath + \"/import\", options).then(() => true);\n    }\n\n    /**\n     * Returns type indexed map with scaffolded collection models\n     * populated with their default field values.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getScaffolds(\n        options?: CommonOptions,\n    ): Promise<{ [key: string]: CollectionModel }> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(this.baseCrudPath + \"/meta/scaffolds\", options);\n    }\n\n    /**\n     * Deletes all records associated with the specified collection.\n     *\n     * @throws {ClientResponseError}\n     */\n    async truncate(collectionIdOrName: string, options?: CommonOptions): Promise<true> {\n        options = Object.assign(\n            {\n                method: \"DELETE\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(\n                this.baseCrudPath +\n                    \"/\" +\n                    encodeURIComponent(collectionIdOrName) +\n                    \"/truncate\",\n                options,\n            )\n            .then(() => true);\n    }\n}\n","import { ClientResponseError } from \"@/ClientResponseError\";\nimport { BaseService } from \"@/services/BaseService\";\nimport { ListResult, LogModel } from \"@/tools/dtos\";\nimport { CommonOptions, ListOptions, LogStatsOptions } from \"@/tools/options\";\n\nexport interface HourlyStats {\n    total: number;\n    date: string;\n}\n\nexport class LogService extends BaseService {\n    /**\n     * Returns paginated logs list.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getList(\n        page = 1,\n        perPage = 30,\n        options?: ListOptions,\n    ): Promise<ListResult<LogModel>> {\n        options = Object.assign({ method: \"GET\" }, options);\n\n        options.query = Object.assign(\n            {\n                page: page,\n                perPage: perPage,\n            },\n            options.query,\n        );\n\n        return this.client.send(\"/api/logs\", options);\n    }\n\n    /**\n     * Returns a single log by its id.\n     *\n     * If `id` is empty it will throw a 404 error.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getOne(id: string, options?: CommonOptions): Promise<LogModel> {\n        if (!id) {\n            throw new ClientResponseError({\n                url: this.client.buildURL(\"/api/logs/\"),\n                status: 404,\n                response: {\n                    code: 404,\n                    message: \"Missing required log id.\",\n                    data: {},\n                },\n            });\n        }\n\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/logs/\" + encodeURIComponent(id), options);\n    }\n\n    /**\n     * Returns logs statistics.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getStats(options?: LogStatsOptions): Promise<Array<HourlyStats>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/logs/stats\", options);\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { CommonOptions } from \"@/tools/options\";\n\nexport interface HealthCheckResponse {\n    code: number;\n    message: string;\n    data: { [key: string]: any };\n}\n\nexport class HealthService extends BaseService {\n    /**\n     * Checks the health status of the api.\n     *\n     * @throws {ClientResponseError}\n     */\n    async check(options?: CommonOptions): Promise<HealthCheckResponse> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/health\", options);\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { CommonOptions, FileOptions } from \"@/tools/options\";\n\nexport class FileService extends BaseService {\n    /**\n     * @deprecated Please replace with `pb.files.getURL()`.\n     */\n    getUrl(\n        record: { [key: string]: any },\n        filename: string,\n        queryParams: FileOptions = {},\n    ): string {\n        console.warn(\"Please replace pb.files.getUrl() with pb.files.getURL()\");\n        return this.getURL(record, filename, queryParams);\n    }\n\n    /**\n     * Builds and returns an absolute record file url for the provided filename.\n     */\n    getURL(\n        record: { [key: string]: any },\n        filename: string,\n        queryParams: FileOptions = {},\n    ): string {\n        if (\n            !filename ||\n            !record?.id ||\n            !(record?.collectionId || record?.collectionName)\n        ) {\n            return \"\";\n        }\n\n        const parts = [];\n        parts.push(\"api\");\n        parts.push(\"files\");\n        parts.push(encodeURIComponent(record.collectionId || record.collectionName));\n        parts.push(encodeURIComponent(record.id));\n        parts.push(encodeURIComponent(filename));\n\n        let result = this.client.buildURL(parts.join(\"/\"));\n\n        if (Object.keys(queryParams).length) {\n            // normalize the download query param for consistency with the Dart sdk\n            if (queryParams.download === false) {\n                delete queryParams.download;\n            }\n\n            const params = new URLSearchParams(queryParams);\n\n            result += (result.includes(\"?\") ? \"&\" : \"?\") + params;\n        }\n\n        return result;\n    }\n\n    /**\n     * Requests a new private file access token for the current auth model.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getToken(options?: CommonOptions): Promise<string> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(\"/api/files/token\", options)\n            .then((data) => data?.token || \"\");\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { CommonOptions } from \"@/tools/options\";\n\nexport interface BackupFileInfo {\n    key: string;\n    size: number;\n    modified: string;\n}\n\nexport class BackupService extends BaseService {\n    /**\n     * Returns list with all available backup files.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFullList(options?: CommonOptions): Promise<Array<BackupFileInfo>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/backups\", options);\n    }\n\n    /**\n     * Initializes a new backup.\n     *\n     * @throws {ClientResponseError}\n     */\n    async create(basename: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: {\n                    name: basename,\n                },\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/backups\", options).then(() => true);\n    }\n\n    /**\n     * Uploads an existing backup file.\n     *\n     * Example:\n     *\n     * ```js\n     * await pb.backups.upload({\n     *     file: new Blob([...]),\n     * });\n     * ```\n     *\n     * @throws {ClientResponseError}\n     */\n    async upload(\n        bodyParams: { [key: string]: any } | FormData,\n        options?: CommonOptions,\n    ): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: bodyParams,\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/backups/upload\", options).then(() => true);\n    }\n\n    /**\n     * Deletes a single backup file.\n     *\n     * @throws {ClientResponseError}\n     */\n    async delete(key: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"DELETE\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(`/api/backups/${encodeURIComponent(key)}`, options)\n            .then(() => true);\n    }\n\n    /**\n     * Initializes an app data restore from an existing backup.\n     *\n     * @throws {ClientResponseError}\n     */\n    async restore(key: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(`/api/backups/${encodeURIComponent(key)}/restore`, options)\n            .then(() => true);\n    }\n\n    /**\n     * @deprecated Please use `getDownloadURL()`.\n     */\n    getDownloadUrl(token: string, key: string): string {\n        console.warn(\n            \"Please replace pb.backups.getDownloadUrl() with pb.backups.getDownloadURL()\",\n        );\n        return this.getDownloadURL(token, key);\n    }\n\n    /**\n     * Builds a download url for a single existing backup using a\n     * superuser file token and the backup file key.\n     *\n     * The file token can be generated via `pb.files.getToken()`.\n     */\n    getDownloadURL(token: string, key: string): string {\n        return this.client.buildURL(\n            `/api/backups/${encodeURIComponent(key)}?token=${encodeURIComponent(token)}`,\n        );\n    }\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { CommonOptions } from \"@/tools/options\";\n\nexport interface CronJob {\n    id: string;\n    expression: string;\n}\n\nexport class CronService extends BaseService {\n    /**\n     * Returns list with all registered cron jobs.\n     *\n     * @throws {ClientResponseError}\n     */\n    async getFullList(options?: CommonOptions): Promise<Array<CronJob>> {\n        options = Object.assign(\n            {\n                method: \"GET\",\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/crons\", options);\n    }\n\n    /**\n     * Runs the specified cron job.\n     *\n     * @throws {ClientResponseError}\n     */\n    async run(jobId: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign(\n            {\n                method: \"POST\",\n            },\n            options,\n        );\n\n        return this.client\n            .send(`/api/crons/${encodeURIComponent(jobId)}`, options)\n            .then(() => true);\n    }\n}\n","/**\n * Checks if the specified value is a file (aka. File, Blob, RN file object).\n */\nexport function isFile(val: any): boolean {\n    return (\n        (typeof Blob !== \"undefined\" && val instanceof Blob) ||\n        (typeof File !== \"undefined\" && val instanceof File) ||\n        // check for React Native file object format\n        // (see https://github.com/pocketbase/pocketbase/discussions/2002#discussioncomment-5254168)\n        (val !== null &&\n            typeof val === \"object\" &&\n            val.uri &&\n            ((typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") ||\n                (typeof global !== \"undefined\" && (global as any).HermesInternal)))\n    );\n}\n\n/**\n * Loosely checks if the specified body is a FormData instance.\n */\nexport function isFormData(body: any): boolean {\n    return (\n        body &&\n        // we are checking the constructor name because FormData\n        // is not available natively in some environments and the\n        // polyfill(s) may not be globally accessible\n        (body.constructor?.name === \"FormData\" ||\n            // fallback to global FormData instance check\n            // note: this is needed because the constructor.name could be different in case of\n            //       custom global FormData implementation, eg. React Native on Android/iOS\n            (typeof FormData !== \"undefined\" && body instanceof FormData))\n    );\n}\n\n/**\n * Checks if the submitted body object has at least one Blob/File field value.\n */\nexport function hasFileField(body: { [key: string]: any }): boolean {\n    for (const key in body) {\n        const values = Array.isArray(body[key]) ? body[key] : [body[key]];\n        for (const v of values) {\n            if (isFile(v)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n/**\n * Converts analyzes the provided body and converts it to FormData\n * in case a plain object with File/Blob values is used.\n */\nexport function convertToFormDataIfNeeded(body: any): any {\n    if (\n        typeof FormData === \"undefined\" ||\n        typeof body === \"undefined\" ||\n        typeof body !== \"object\" ||\n        body === null ||\n        isFormData(body) ||\n        !hasFileField(body)\n    ) {\n        return body;\n    }\n\n    const form = new FormData();\n\n    for (const key in body) {\n        const val = body[key];\n\n        // skip undefined values for consistency with JSON.stringify\n        // (see https://github.com/pocketbase/pocketbase/issues/6731#issuecomment-2812382827)\n        if (typeof val === \"undefined\") {\n            continue;\n        }\n\n        if (typeof val === \"object\" && !hasFileField({ data: val })) {\n            // send json-like values as jsonPayload to avoid the implicit string value normalization\n            let payload: { [key: string]: any } = {};\n            payload[key] = val;\n            form.append(\"@jsonPayload\", JSON.stringify(payload));\n        } else {\n            // in case of mixed string and file/blob\n            const normalizedVal = Array.isArray(val) ? val : [val];\n            for (let v of normalizedVal) {\n                form.append(key, v);\n            }\n        }\n    }\n\n    return form;\n}\n\n/**\n * Converts the provided FormData instance into a plain object.\n *\n * For consistency with the server multipart/form-data inferring,\n * the following normalization rules are applied for plain multipart string values:\n *   - \"true\" is converted to the json \"true\"\n *   - \"false\" is converted to the json \"false\"\n *   - numeric strings are converted to json number ONLY if the resulted\n *     minimal number string representation is the same as the provided raw string\n *     (aka. scientific notations, \"Infinity\", \"0.0\", \"0001\", etc. are kept as string)\n *   - any other string (empty string too) is left as it is\n */\nexport function convertFormDataToObject(formData: FormData): { [key: string]: any } {\n    let result: { [key: string]: any } = {};\n\n    formData.forEach((v, k) => {\n        if (k === \"@jsonPayload\" && typeof v == \"string\") {\n            try {\n                let parsed = JSON.parse(v);\n                Object.assign(result, parsed);\n            } catch (err) {\n                console.warn(\"@jsonPayload error:\", err);\n            }\n        } else {\n            if (typeof result[k] !== \"undefined\") {\n                if (!Array.isArray(result[k])) {\n                    result[k] = [result[k]];\n                }\n                result[k].push(inferFormDataValue(v));\n            } else {\n                result[k] = inferFormDataValue(v);\n            }\n        }\n    });\n\n    return result;\n}\n\nconst inferNumberCharsRegex = /^[\\-\\.\\d]+$/;\n\nfunction inferFormDataValue(value: any): any {\n    if (typeof value != \"string\") {\n        return value;\n    }\n\n    if (value == \"true\") {\n        return true;\n    }\n\n    if (value == \"false\") {\n        return false;\n    }\n\n    // note: expects the provided raw string to match exactly with the minimal string representation of the parsed number\n    if (\n        (value[0] === \"-\" || (value[0] >= \"0\" && value[0] <= \"9\")) &&\n        inferNumberCharsRegex.test(value)\n    ) {\n        let num = +value;\n        if (\"\" + num === value) {\n            return num;\n        }\n    }\n\n    return value;\n}\n","import { BaseService } from \"@/services/BaseService\";\nimport { isFile, isFormData, convertFormDataToObject } from \"@/tools/formdata\";\nimport {\n    SendOptions,\n    RecordOptions,\n    normalizeUnknownQueryParams,\n    serializeQueryParams,\n} from \"@/tools/options\";\n\nexport interface BatchRequest {\n    method: string;\n    url: string;\n    json?: { [key: string]: any };\n    files?: { [key: string]: Array<any> };\n    headers?: { [key: string]: string };\n}\n\nexport interface BatchRequestResult {\n    status: number;\n    body: any;\n}\n\nexport class BatchService extends BaseService {\n    private requests: Array<BatchRequest> = [];\n    private subs: { [key: string]: SubBatchService } = {};\n\n    /**\n     * Starts constructing a batch request entry for the specified collection.\n     */\n    collection(collectionIdOrName: string): SubBatchService {\n        if (!this.subs[collectionIdOrName]) {\n            this.subs[collectionIdOrName] = new SubBatchService(\n                this.requests,\n                collectionIdOrName,\n            );\n        }\n\n        return this.subs[collectionIdOrName];\n    }\n\n    /**\n     * Sends the batch requests.\n     *\n     * @throws {ClientResponseError}\n     */\n    async send(options?: SendOptions): Promise<Array<BatchRequestResult>> {\n        const formData = new FormData();\n\n        const jsonData = [];\n\n        for (let i = 0; i < this.requests.length; i++) {\n            const req = this.requests[i];\n\n            jsonData.push({\n                method: req.method,\n                url: req.url,\n                headers: req.headers,\n                body: req.json,\n            });\n\n            if (req.files) {\n                for (let key in req.files) {\n                    const files = req.files[key] || [];\n                    for (let file of files) {\n                        formData.append(\"requests.\" + i + \".\" + key, file);\n                    }\n                }\n            }\n        }\n\n        formData.append(\"@jsonPayload\", JSON.stringify({ requests: jsonData }));\n\n        options = Object.assign(\n            {\n                method: \"POST\",\n                body: formData,\n            },\n            options,\n        );\n\n        return this.client.send(\"/api/batch\", options);\n    }\n}\n\nexport class SubBatchService {\n    private requests: Array<BatchRequest> = [];\n    private readonly collectionIdOrName: string;\n\n    constructor(requests: Array<BatchRequest>, collectionIdOrName: string) {\n        this.requests = requests;\n        this.collectionIdOrName = collectionIdOrName;\n    }\n\n    /**\n     * Registers a record upsert request into the current batch queue.\n     *\n     * The request will be executed as update if `bodyParams` have a valid existing record `id` value, otherwise - create.\n     */\n    upsert(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): void {\n        options = Object.assign(\n            {\n                body: bodyParams || {},\n            },\n            options,\n        );\n\n        const request: BatchRequest = {\n            method: \"PUT\",\n            url:\n                \"/api/collections/\" +\n                encodeURIComponent(this.collectionIdOrName) +\n                \"/records\",\n        };\n\n        this.prepareRequest(request, options);\n\n        this.requests.push(request);\n    }\n\n    /**\n     * Registers a record create request into the current batch queue.\n     */\n    create(\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): void {\n        options = Object.assign(\n            {\n                body: bodyParams || {},\n            },\n            options,\n        );\n\n        const request: BatchRequest = {\n            method: \"POST\",\n            url:\n                \"/api/collections/\" +\n                encodeURIComponent(this.collectionIdOrName) +\n                \"/records\",\n        };\n\n        this.prepareRequest(request, options);\n\n        this.requests.push(request);\n    }\n\n    /**\n     * Registers a record update request into the current batch queue.\n     */\n    update(\n        id: string,\n        bodyParams?: { [key: string]: any } | FormData,\n        options?: RecordOptions,\n    ): void {\n        options = Object.assign(\n            {\n                body: bodyParams || {},\n            },\n            options,\n        );\n\n        const request: BatchRequest = {\n            method: \"PATCH\",\n            url:\n                \"/api/collections/\" +\n                encodeURIComponent(this.collectionIdOrName) +\n                \"/records/\" +\n                encodeURIComponent(id),\n        };\n\n        this.prepareRequest(request, options);\n\n        this.requests.push(request);\n    }\n\n    /**\n     * Registers a record delete request into the current batch queue.\n     */\n    delete(id: string, options?: SendOptions): void {\n        options = Object.assign({}, options);\n\n        const request: BatchRequest = {\n            method: \"DELETE\",\n            url:\n                \"/api/collections/\" +\n                encodeURIComponent(this.collectionIdOrName) +\n                \"/records/\" +\n                encodeURIComponent(id),\n        };\n\n        this.prepareRequest(request, options);\n\n        this.requests.push(request);\n    }\n\n    private prepareRequest(request: BatchRequest, options: SendOptions) {\n        normalizeUnknownQueryParams(options);\n\n        request.headers = options.headers;\n        request.json = {};\n        request.files = {};\n\n        // serialize query parameters\n        // -----------------------------------------------------------\n        if (typeof options.query !== \"undefined\") {\n            const query = serializeQueryParams(options.query);\n            if (query) {\n                request.url += (request.url.includes(\"?\") ? \"&\" : \"?\") + query;\n            }\n        }\n\n        // extract json and files body data\n        // -----------------------------------------------------------\n        let body = options.body;\n        if (isFormData(body)) {\n            body = convertFormDataToObject(body);\n        }\n\n        for (const key in body) {\n            const val = body[key];\n\n            if (isFile(val)) {\n                request.files[key] = request.files[key] || [];\n                request.files[key].push(val);\n            } else if (Array.isArray(val)) {\n                const foundFiles = [];\n                const foundRegular = [];\n                for (const v of val) {\n                    if (isFile(v)) {\n                        foundFiles.push(v);\n                    } else {\n                        foundRegular.push(v);\n                    }\n                }\n\n                if (foundFiles.length > 0 && foundFiles.length == val.length) {\n                    // only files\n                    // ---\n                    request.files[key] = request.files[key] || [];\n                    for (let file of foundFiles) {\n                        request.files[key].push(file);\n                    }\n                } else {\n                    // empty or mixed array (both regular and File/Blob values)\n                    // ---\n                    request.json[key] = foundRegular;\n\n                    if (foundFiles.length > 0) {\n                        // add \"+\" to append if not already since otherwise\n                        // the existing regular files will be deleted\n                        // (the mixed values order is preserved only within their corresponding groups)\n                        let fileKey = key;\n                        if (!key.startsWith(\"+\") && !key.endsWith(\"+\")) {\n                            fileKey += \"+\";\n                        }\n\n                        request.files[fileKey] = request.files[fileKey] || [];\n                        for (let file of foundFiles) {\n                            request.files[fileKey].push(file);\n                        }\n                    }\n                }\n            } else {\n                request.json[key] = val;\n            }\n        }\n    }\n}\n","import { ClientResponseError } from \"@/ClientResponseError\";\nimport { BaseAuthStore } from \"@/stores/BaseAuthStore\";\nimport { LocalAuthStore } from \"@/stores/LocalAuthStore\";\nimport { SettingsService } from \"@/services/SettingsService\";\nimport { RecordService } from \"@/services/RecordService\";\nimport { CollectionService } from \"@/services/CollectionService\";\nimport { LogService } from \"@/services/LogService\";\nimport { RealtimeService } from \"@/services/RealtimeService\";\nimport { HealthService } from \"@/services/HealthService\";\nimport { FileService } from \"@/services/FileService\";\nimport { BackupService } from \"@/services/BackupService\";\nimport { CronService } from \"@/services/CronService\";\nimport { BatchService } from \"@/services/BatchService\";\nimport { RecordModel } from \"@/tools/dtos\";\nimport {\n    SendOptions,\n    FileOptions,\n    normalizeUnknownQueryParams,\n    serializeQueryParams,\n} from \"@/tools/options\";\nimport { isFormData, convertToFormDataIfNeeded } from \"@/tools/formdata\";\n\nexport interface BeforeSendResult {\n    [key: string]: any; // for backward compatibility\n    url?: string;\n    options?: { [key: string]: any };\n}\n\n/**\n * PocketBase JS Client.\n */\nexport default class Client {\n    /**\n     * The base PocketBase backend url address (eg. 'http://127.0.0.1.8090').\n     */\n    baseURL: string;\n\n    /**\n     * Legacy getter alias for baseURL.\n     * @deprecated Please replace with baseURL.\n     */\n    get baseUrl(): string {\n        return this.baseURL;\n    }\n\n    /**\n     * Legacy setter alias for baseURL.\n     * @deprecated Please replace with baseURL.\n     */\n    set baseUrl(v: string) {\n        this.baseURL = v;\n    }\n\n    /**\n     * Hook that get triggered right before sending the fetch request,\n     * allowing you to inspect and modify the url and request options.\n     *\n     * For list of the possible options check https://developer.mozilla.org/en-US/docs/Web/API/fetch#options\n     *\n     * You can return a non-empty result object `{ url, options }` to replace the url and request options entirely.\n     *\n     * Example:\n     * ```js\n     * const pb = new PocketBase(\"https://example.com\")\n     *\n     * pb.beforeSend = function (url, options) {\n     *     options.headers = Object.assign({}, options.headers, {\n     *         'X-Custom-Header': 'example',\n     *     })\n     *\n     *     return { url, options }\n     * }\n     *\n     * // use the created client as usual...\n     * ```\n     */\n    beforeSend?: (\n        url: string,\n        options: SendOptions,\n    ) => BeforeSendResult | Promise<BeforeSendResult>;\n\n    /**\n     * Hook that get triggered after successfully sending the fetch request,\n     * allowing you to inspect/modify the response object and its parsed data.\n     *\n     * Returns the new Promise resolved `data` that will be returned to the client.\n     *\n     * Example:\n     * ```js\n     * const pb = new PocketBase(\"https://example.com\")\n     *\n     * pb.afterSend = function (response, data, options) {\n     *     if (response.status != 200) {\n     *         throw new ClientResponseError({\n     *             url:      response.url,\n     *             status:   response.status,\n     *             response: { ... },\n     *         })\n     *     }\n     *\n     *     return data;\n     * }\n     *\n     * // use the created client as usual...\n     * ```\n     */\n    afterSend?: ((response: Response, data: any) => any) &\n        ((response: Response, data: any, options: SendOptions) => any);\n\n    /**\n     * Optional language code (default to `en-US`) that will be sent\n     * with the requests to the server as `Accept-Language` header.\n     */\n    lang: string;\n\n    /**\n     * A replaceable instance of the local auth store service.\n     */\n    authStore: BaseAuthStore;\n\n    /**\n     * An instance of the service that handles the **Settings APIs**.\n     */\n    readonly settings: SettingsService;\n\n    /**\n     * An instance of the service that handles the **Collection APIs**.\n     */\n    readonly collections: CollectionService;\n\n    /**\n     * An instance of the service that handles the **File APIs**.\n     */\n    readonly files: FileService;\n\n    /**\n     * An instance of the service that handles the **Log APIs**.\n     */\n    readonly logs: LogService;\n\n    /**\n     * An instance of the service that handles the **Realtime APIs**.\n     */\n    readonly realtime: RealtimeService;\n\n    /**\n     * An instance of the service that handles the **Health APIs**.\n     */\n    readonly health: HealthService;\n\n    /**\n     * An instance of the service that handles the **Backup APIs**.\n     */\n    readonly backups: BackupService;\n\n    /**\n     * An instance of the service that handles the **Cron APIs**.\n     */\n    readonly crons: CronService;\n\n    private cancelControllers: { [key: string]: AbortController } = {};\n    private recordServices: { [key: string]: RecordService } = {};\n    private enableAutoCancellation: boolean = true;\n\n    constructor(baseURL = \"/\", authStore?: BaseAuthStore | null, lang = \"en-US\") {\n        this.baseURL = baseURL;\n        this.lang = lang;\n\n        if (authStore) {\n            this.authStore = authStore;\n        } else if (typeof window != \"undefined\" && !!(window as any).Deno) {\n            // note: to avoid common security issues we fallback to runtime/memory store in case the code is running in Deno env\n            this.authStore = new BaseAuthStore();\n        } else {\n            this.authStore = new LocalAuthStore();\n        }\n\n        // common services\n        this.collections = new CollectionService(this);\n        this.files = new FileService(this);\n        this.logs = new LogService(this);\n        this.settings = new SettingsService(this);\n        this.realtime = new RealtimeService(this);\n        this.health = new HealthService(this);\n        this.backups = new BackupService(this);\n        this.crons = new CronService(this);\n    }\n\n    /**\n     * @deprecated\n     * With PocketBase v0.23.0 admins are converted to a regular auth\n     * collection named \"_superusers\", aka. you can use directly collection(\"_superusers\").\n     */\n    get admins(): RecordService {\n        return this.collection(\"_superusers\");\n    }\n\n    /**\n     * Creates a new batch handler for sending multiple transactional\n     * create/update/upsert/delete collection requests in one network call.\n     *\n     * Example:\n     * ```js\n     * const batch = pb.createBatch();\n     *\n     * batch.collection(\"example1\").create({ ... })\n     * batch.collection(\"example2\").update(\"RECORD_ID\", { ... })\n     * batch.collection(\"example3\").delete(\"RECORD_ID\")\n     * batch.collection(\"example4\").upsert({ ... })\n     *\n     * await batch.send()\n     * ```\n     */\n    createBatch(): BatchService {\n        return new BatchService(this);\n    }\n\n    /**\n     * Returns the RecordService associated to the specified collection.\n     */\n    collection<M = RecordModel>(idOrName: string): RecordService<M> {\n        if (!this.recordServices[idOrName]) {\n            this.recordServices[idOrName] = new RecordService(this, idOrName);\n        }\n\n        return this.recordServices[idOrName];\n    }\n\n    /**\n     * Globally enable or disable auto cancellation for pending duplicated requests.\n     */\n    autoCancellation(enable: boolean): Client {\n        this.enableAutoCancellation = !!enable;\n\n        return this;\n    }\n\n    /**\n     * Cancels single request by its cancellation key.\n     */\n    cancelRequest(requestKey: string): Client {\n        if (this.cancelControllers[requestKey]) {\n            this.cancelControllers[requestKey].abort();\n            delete this.cancelControllers[requestKey];\n        }\n\n        return this;\n    }\n\n    /**\n     * Cancels all pending requests.\n     */\n    cancelAllRequests(): Client {\n        for (let k in this.cancelControllers) {\n            this.cancelControllers[k].abort();\n        }\n\n        this.cancelControllers = {};\n\n        return this;\n    }\n\n    /**\n     * Constructs a filter expression with placeholders populated from a parameters object.\n     *\n     * Placeholder parameters are defined with the `{:paramName}` notation.\n     *\n     * The following parameter values are supported:\n     *\n     * - `string` (_single quotes are autoescaped_)\n     * - `number`\n     * - `boolean`\n     * - `Date` object (_stringified into the PocketBase datetime format_)\n     * - `null`\n     * - everything else is converted to a string using `JSON.stringify()`\n     *\n     * Example:\n     *\n     * ```js\n     * pb.collection(\"example\").getFirstListItem(pb.filter(\n     *    'title ~ {:title} && created >= {:created}',\n     *    { title: \"example\", created: new Date()}\n     * ))\n     * ```\n     */\n    filter(raw: string, params?: { [key: string]: any }): string {\n        if (!params) {\n            return raw;\n        }\n\n        for (let key in params) {\n            let val = params[key];\n            switch (typeof val) {\n                case \"boolean\":\n                case \"number\":\n                    val = \"\" + val;\n                    break;\n                case \"string\":\n                    val = \"'\" + val.replace(/'/g, \"\\\\'\") + \"'\";\n                    break;\n                default:\n                    if (val === null) {\n                        val = \"null\";\n                    } else if (val instanceof Date) {\n                        val = \"'\" + val.toISOString().replace(\"T\", \" \") + \"'\";\n                    } else {\n                        val = \"'\" + JSON.stringify(val).replace(/'/g, \"\\\\'\") + \"'\";\n                    }\n            }\n            raw = raw.replaceAll(\"{:\" + key + \"}\", val);\n        }\n\n        return raw;\n    }\n\n    /**\n     * @deprecated Please use `pb.files.getURL()`.\n     */\n    getFileUrl(\n        record: { [key: string]: any },\n        filename: string,\n        queryParams: FileOptions = {},\n    ): string {\n        console.warn(\"Please replace pb.getFileUrl() with pb.files.getURL()\");\n        return this.files.getURL(record, filename, queryParams);\n    }\n\n    /**\n     * @deprecated Please use `pb.buildURL()`.\n     */\n    buildUrl(path: string): string {\n        console.warn(\"Please replace pb.buildUrl() with pb.buildURL()\");\n        return this.buildURL(path);\n    }\n\n    /**\n     * Builds a full client url by safely concatenating the provided path.\n     */\n    buildURL(path: string): string {\n        let url = this.baseURL;\n\n        // construct an absolute base url if in a browser environment\n        if (\n            typeof window !== \"undefined\" &&\n            !!window.location &&\n            !url.startsWith(\"https://\") &&\n            !url.startsWith(\"http://\")\n        ) {\n            url = window.location.origin?.endsWith(\"/\")\n                ? window.location.origin.substring(0, window.location.origin.length - 1)\n                : window.location.origin || \"\";\n\n            if (!this.baseURL.startsWith(\"/\")) {\n                url += window.location.pathname || \"/\";\n                url += url.endsWith(\"/\") ? \"\" : \"/\";\n            }\n\n            url += this.baseURL;\n        }\n\n        // concatenate the path\n        if (path) {\n            url += url.endsWith(\"/\") ? \"\" : \"/\"; // append trailing slash if missing\n            url += path.startsWith(\"/\") ? path.substring(1) : path;\n        }\n\n        return url;\n    }\n\n    /**\n     * Sends an api http request.\n     *\n     * @throws {ClientResponseError}\n     */\n    async send<T = any>(path: string, options: SendOptions): Promise<T> {\n        options = this.initSendOptions(path, options);\n\n        // build url + path\n        let url = this.buildURL(path);\n\n        if (this.beforeSend) {\n            const result = Object.assign({}, await this.beforeSend(url, options));\n            if (\n                typeof result.url !== \"undefined\" ||\n                typeof result.options !== \"undefined\"\n            ) {\n                url = result.url || url;\n                options = result.options || options;\n            } else if (Object.keys(result).length) {\n                // legacy behavior\n                options = result as SendOptions;\n                console?.warn &&\n                    console.warn(\n                        \"Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`.\",\n                    );\n            }\n        }\n\n        // serialize the query parameters\n        if (typeof options.query !== \"undefined\") {\n            const query = serializeQueryParams(options.query);\n            if (query) {\n                url += (url.includes(\"?\") ? \"&\" : \"?\") + query;\n            }\n            delete options.query;\n        }\n\n        // ensures that the json body is serialized\n        if (\n            this.getHeader(options.headers, \"Content-Type\") == \"application/json\" &&\n            options.body &&\n            typeof options.body !== \"string\"\n        ) {\n            options.body = JSON.stringify(options.body);\n        }\n\n        // early throw an abort error in case the request was already cancelled\n        const fetchFunc = options.fetch || fetch;\n\n        // send the request\n        return fetchFunc(url, options)\n            .then(async (response) => {\n                let data: any = {};\n\n                try {\n                    data = await response.json();\n                } catch (err) {\n                    // @todo map against the response content type\n                    // all api responses are expected to return json\n                    // with exception of the realtime events and 204\n                    if (\n                        options.signal?.aborted ||\n                        (\n                            typeof DOMException !== \"undefined\" && err instanceof DOMException &&\n                            // https://developer.mozilla.org/en-US/docs/Web/API/DOMException#aborterror\n                            (err.name == \"AbortError\" || err.code == 20)\n                        )\n                    ) {\n                        throw err;\n                    }\n                }\n\n                if (this.afterSend) {\n                    data = await this.afterSend(response, data, options);\n                }\n\n                if (response.status >= 400) {\n                    throw new ClientResponseError({\n                        url: response.url,\n                        status: response.status,\n                        data: data,\n                    });\n                }\n\n                return data as T;\n            })\n            .catch((err) => {\n                // wrap to normalize all errors\n                throw new ClientResponseError(err);\n            });\n    }\n\n    /**\n     * Shallow copy the provided object and takes care to initialize\n     * any options required to preserve the backward compatability.\n     *\n     * @param  {SendOptions} options\n     * @return {SendOptions}\n     */\n    private initSendOptions(path: string, options: SendOptions): SendOptions {\n        options = Object.assign({ method: \"GET\" } as SendOptions, options);\n\n        // auto convert the body to FormData, if needed\n        options.body = convertToFormDataIfNeeded(options.body);\n\n        // move unknown send options as query parameters\n        normalizeUnknownQueryParams(options);\n\n        // requestKey normalizations for backward-compatibility\n        // ---\n        options.query = Object.assign({}, options.params, options.query);\n        if (typeof options.requestKey === \"undefined\") {\n            if (options.$autoCancel === false || options.query.$autoCancel === false) {\n                options.requestKey = null;\n            } else if (options.$cancelKey || options.query.$cancelKey) {\n                options.requestKey = options.$cancelKey || options.query.$cancelKey;\n            }\n        }\n        // remove the deprecated special cancellation params from the other query params\n        delete options.$autoCancel;\n        delete options.query.$autoCancel;\n        delete options.$cancelKey;\n        delete options.query.$cancelKey;\n        // ---\n\n        // add the json header, if not explicitly set\n        // (for FormData body the Content-Type header should be skipped since the boundary is autogenerated)\n        if (\n            this.getHeader(options.headers, \"Content-Type\") === null &&\n            !isFormData(options.body)\n        ) {\n            options.headers = Object.assign({}, options.headers, {\n                \"Content-Type\": \"application/json\",\n            });\n        }\n\n        // add Accept-Language header, if not explicitly set\n        if (this.getHeader(options.headers, \"Accept-Language\") === null) {\n            options.headers = Object.assign({}, options.headers, {\n                \"Accept-Language\": this.lang,\n            });\n        }\n\n        // check if Authorization header can be added\n        if (\n            // has valid token\n            this.authStore.token &&\n            // auth header is not explicitly set\n            this.getHeader(options.headers, \"Authorization\") === null\n        ) {\n            options.headers = Object.assign({}, options.headers, {\n                Authorization: this.authStore.token,\n            });\n        }\n\n        // handle auto cancelation for duplicated pending request\n        if (this.enableAutoCancellation && options.requestKey !== null) {\n            const requestKey = options.requestKey || (options.method || \"GET\") + path;\n\n            delete options.requestKey;\n\n            // cancel previous pending requests\n            this.cancelRequest(requestKey);\n\n            const controller = new AbortController();\n            this.cancelControllers[requestKey] = controller;\n            options.signal = controller.signal;\n        }\n\n        return options;\n    }\n\n    /**\n     * Extracts the header with the provided name in case-insensitive manner.\n     * Returns `null` if no header matching the name is found.\n     */\n    private getHeader(\n        headers: { [key: string]: string } | undefined,\n        name: string,\n    ): string | null {\n        headers = headers || {};\n        name = name.toLowerCase();\n\n        for (let key in headers) {\n            if (key.toLowerCase() == name) {\n                return headers[key];\n            }\n        }\n\n        return null;\n    }\n}\n","import { BaseAuthStore, AuthRecord } from \"@/stores/BaseAuthStore\";\n\nexport type AsyncSaveFunc = (serializedPayload: string) => Promise<void>;\n\nexport type AsyncClearFunc = () => Promise<void>;\n\ntype queueFunc = () => Promise<void>;\n\n/**\n * AsyncAuthStore is a helper auth store implementation\n * that could be used with any external async persistent layer\n * (key-value db, local file, etc.).\n *\n * Here is an example with the React Native AsyncStorage package:\n *\n * ```\n * import AsyncStorage from \"@react-native-async-storage/async-storage\";\n * import PocketBase, { AsyncAuthStore } from \"pocketbase\";\n *\n * const store = new AsyncAuthStore({\n *     save:    async (serialized) => AsyncStorage.setItem(\"pb_auth\", serialized),\n *     initial: AsyncStorage.getItem(\"pb_auth\"),\n * });\n *\n * const pb = new PocketBase(\"https://example.com\", store)\n * ```\n */\nexport class AsyncAuthStore extends BaseAuthStore {\n    private saveFunc: AsyncSaveFunc;\n    private clearFunc?: AsyncClearFunc;\n    private queue: Array<queueFunc> = [];\n\n    constructor(config: {\n        // The async function that is called every time\n        // when the auth store state needs to be persisted.\n        save: AsyncSaveFunc;\n\n        /// An *optional* async function that is called every time\n        /// when the auth store needs to be cleared.\n        ///\n        /// If not explicitly set, `saveFunc` with empty data will be used.\n        clear?: AsyncClearFunc;\n\n        // An *optional* initial data to load into the store.\n        initial?: string | Promise<any>;\n    }) {\n        super();\n\n        this.saveFunc = config.save;\n        this.clearFunc = config.clear;\n\n        this._enqueue(() => this._loadInitial(config.initial));\n    }\n\n    /**\n     * @inheritdoc\n     */\n    save(token: string, record?: AuthRecord): void {\n        super.save(token, record);\n\n        let value = \"\";\n        try {\n            value = JSON.stringify({ token, record });\n        } catch (err) {\n            console.warn(\"AsyncAuthStore: failed to stringify the new state\");\n        }\n\n        this._enqueue(() => this.saveFunc(value));\n    }\n\n    /**\n     * @inheritdoc\n     */\n    clear(): void {\n        super.clear();\n\n        if (this.clearFunc) {\n            this._enqueue(() => this.clearFunc!());\n        } else {\n            this._enqueue(() => this.saveFunc(\"\"));\n        }\n    }\n\n    /**\n     * Initializes the auth store state.\n     */\n    private async _loadInitial(payload?: string | Promise<any>) {\n        try {\n            payload = await payload;\n\n            if (payload) {\n                let parsed;\n                if (typeof payload === \"string\") {\n                    parsed = JSON.parse(payload) || {};\n                } else if (typeof payload === \"object\") {\n                    parsed = payload;\n                }\n\n                this.save(parsed.token || \"\", parsed.record || parsed.model || null);\n            }\n        } catch (_) {}\n    }\n\n    /**\n     * Appends an async function to the queue.\n     */\n    private _enqueue(asyncCallback: () => Promise<void>) {\n        this.queue.push(asyncCallback);\n\n        if (this.queue.length == 1) {\n            this._dequeue();\n        }\n    }\n\n    /**\n     * Starts the queue processing.\n     */\n    private _dequeue() {\n        if (!this.queue.length) {\n            return;\n        }\n\n        this.queue[0]().finally(() => {\n            this.queue.shift();\n\n            if (!this.queue.length) {\n                return;\n            }\n\n            this._dequeue();\n        });\n    }\n}\n"],"names":["ClientResponseError","AppRouteRouteModule","Error","constructor","errData","super","this","url","status","response","isAbort","originalError","Object","setPrototypeOf","prototype","data","DOMException","name","code","message","cause","includes","toJSON","fieldContentRegExp","cookieParse","str","options","result","decode","assign","defaultDecode","index","length","eqIdx","indexOf","endIdx","lastIndexOf","key","slice","trim","undefined","val","charCodeAt","_","cookieSerialize","opt","encode","defaultEncode","test","TypeError","value","maxAge","isNaN","isFinite","Math","floor","domain","path","expires","isDate","toString","call","Date","valueOf","toUTCString","httpOnly","secure","priority","toLowerCase","sameSite","decodeURIComponent","encodeURIComponent","isReactNative","navigator","product","global","HermesInternal","atobPolyfill","getTokenPayload","token","encodedPayload","split","map","c","join","JSON","parse","e","isTokenExpired","expirationThreshold","payload","keys","exp","now","atob","input","String","replace","bs","buffer","bc","idx","output","charAt","fromCharCode","defaultCookieKey","BaseAuthStore","baseToken","baseModel","_onChangeCallbacks","record","model","isValid","isSuperuser","type","collectionName","collectionId","isAdmin","console","warn","isAuthRecord","save","triggerChange","clear","loadFromCookie","cookie","rawData","Array","isArray","exportToCookie","defaultOptions","stringify","resultLength","Blob","size","id","email","extraProps","prop","onChange","callback","fireImmediately","push","i","splice","LocalAuthStore","storageKey","storageFallback","_bindStorageEvent","_storageGet","_storageSet","_storageRemove","window","localStorage","rawValue","getItem","normalizedVal","setItem","removeItem","addEventListener","BaseService","client","SettingsService","getAll","method","send","update","bodyParams","body","testS3","filesystem","then","testEmail","collectionIdOrName","toEmail","emailTemplate","template","collection","generateAppleClientSecret","clientId","teamId","keyId","privateKey","duration","knownSendOptionsKeys","normalizeUnknownQueryParams","query","serializeQueryParams","params","encodedKey","arrValue","v","prepareQueryParamValue","toISOString","RealtimeService","eventSource","subscriptions","lastSentSubscriptions","maxConnectTimeout","reconnectAttempts","maxReconnectAttempts","Infinity","predefinedReconnectIntervals","pendingConnects","isConnected","subscribe","topic","serialized","headers","listener","msgEvent","submitSubscriptions","connect","async","unsubscribeByTopicAndListener","unsubscribe","needToSubmit","subs","getSubscriptionsByTopic","hasSubscriptionListeners","removeEventListener","disconnect","unsubscribeByPrefix","keyPrefix","hasAtleastOneTopic","startsWith","exist","keyToCheck","addAllSubscriptionListeners","getNonEmptySubscriptionKeys","requestKey","getSubscriptionsCancelKey","catch","err","removeAllSubscriptionListeners","Promise","resolve","reject","initConnect","clearTimeout","connectTimeoutId","setTimeout","connectErrorHandler","EventSource","buildURL","onerror","lastEventId","retries","hasUnsentSubscriptions","p","reconnectTimeoutId","connectSubs","latestTopics","t","timeout","fromReconnect","onDisconnect","cancelRequest","close","CrudService","getFullList","batchOrqueryParams","_getFullList","batch","getList","page","perPage","baseCrudPath","responseData","items","item","getFirstListItem","filter","skipTotal","getOne","create","batchSize","request","list","concat","normalizeLegacyOptionsArgs","legacyWarn","baseOptions","bodyOrOptions","hasQuery","resetAutoRefresh","_resetAutoRefresh","RecordService","baseCollectionPath","isSuperusers","realtime","batchOrOptions","authStore","authExpand","expand","authRecord","delete","success","authResponse","listAuthMethods","fields","authWithPassword","usernameOrEmail","password","autoRefreshThreshold","identity","autoRefresh","authData","registerAutoRefresh","threshold","refreshFunc","reauthenticateFunc","oldBeforeSend","beforeSend","oldModel","unsubStoreChange","newToken","sendOptions","oldToken","authRefresh","authWithOAuth2Code","provider","codeVerifier","redirectURL","createData","authWithOAuth2","args","config","eagerDefaultPopup","urlCallback","openBrowserPopup","cleanup","requestKeyOptions","authMethods","oauth2","providers","find","cancelController","signal","onabort","oldState","state","error","scopes","replacements","_replaceQueryParams","authURL","location","href","requestPasswordReset","confirmPasswordReset","passwordResetToken","passwordConfirm","requestVerification","confirmVerification","verificationToken","verified","requestEmailChange","newEmail","confirmEmailChange","emailChangeToken","listExternalAuths","recordId","unlinkExternalAuth","ea","requestOTP","authWithOTP","otpId","impersonate","Authorization","Client","baseURL","lang","urlPath","substring","parsedParams","rawParams","param","pair","hasOwnProperty","open","width","height","windowWidth","innerWidth","windowHeight","innerHeight","left","top","CollectionService","import","collections","deleteMissing","getScaffolds","truncate","LogService","getStats","HealthService","check","FileService","getUrl","filename","queryParams","getURL","parts","download","URLSearchParams","getToken","BackupService","basename","upload","restore","getDownloadUrl","getDownloadURL","CronService","run","jobId","isFile","File","uri","isFormData","FormData","hasFileField","values","inferNumberCharsRegex","inferFormDataValue","num","BatchService","requests","SubBatchService","formData","jsonData","req","json","files","file","append","upsert","prepareRequest","convertFormDataToObject","forEach","k","parsed","foundFiles","foundRegular","fileKey","endsWith","baseUrl","cancelControllers","recordServices","enableAutoCancellation","Deno","logs","settings","health","backups","crons","admins","createBatch","idOrName","autoCancellation","enable","abort","cancelAllRequests","raw","replaceAll","getFileUrl","buildUrl","origin","pathname","initSendOptions","getHeader","fetch","aborted","afterSend","convertToFormDataIfNeeded","form","$autoCancel","$cancelKey","controller","AbortController","AsyncAuthStore","queue","saveFunc","clearFunc","_enqueue","_loadInitial","initial","asyncCallback","_dequeue","finally","shift"],"mappings":"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","ignoreList":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}